import {
  WaiterState,
  checkExceptions,
  createWaiter
} from "./chunk-7ZRT44SL.js";
import {
  AwsSdkSigV4Signer,
  Client,
  Command,
  DEFAULT_MAX_ATTEMPTS,
  DEFAULT_RETRY_MODE,
  DEFAULT_USE_DUALSTACK_ENDPOINT,
  DEFAULT_USE_FIPS_ENDPOINT,
  DefaultIdentityProviderConfig,
  EndpointCache,
  FetchHttpHandler,
  HttpRequest,
  NoOpLogger,
  ServiceException,
  Sha256,
  awsEndpointFunctions,
  calculateBodyLength,
  collectBody,
  createAggregatedClient,
  createDefaultUserAgentProvider,
  createPaginator,
  customEndpointFunctions,
  decorateServiceException,
  expectNonNull,
  expectString,
  extendedEncodeURIComponent,
  fromBase64,
  fromUtf8,
  getArrayIfSingleItem,
  getAwsRegionExtensionConfiguration,
  getContentLengthPlugin,
  getDefaultExtensionConfiguration,
  getEndpointPlugin,
  getHostHeaderPlugin,
  getHttpAuthSchemeEndpointRuleSetPlugin,
  getHttpHandlerExtensionConfiguration,
  getHttpSigningPlugin,
  getLoggerPlugin,
  getRecursionDetectionPlugin,
  getRetryPlugin,
  getSerdePlugin,
  getSmithyContext,
  getUserAgentPlugin,
  invalidProvider,
  isArrayBuffer,
  loadConfigsForDefaultMode,
  normalizeProvider,
  parseBoolean,
  parseRfc3339DateTimeWithOffset,
  parseUrl,
  parseXmlBody,
  parseXmlErrorBody,
  resolveAwsRegionExtensionConfiguration,
  resolveAwsSdkSigV4Config,
  resolveDefaultRuntimeConfig,
  resolveDefaultsModeConfig,
  resolveEndpoint,
  resolveEndpointConfig,
  resolveHostHeaderConfig,
  resolveHttpHandlerRuntimeConfig,
  resolveRegionConfig,
  resolveRetryConfig,
  resolveUserAgentConfig,
  serializeDateTime,
  serializeFloat,
  setFeature,
  streamCollector,
  strictParseFloat,
  strictParseInt32,
  strictParseLong,
  toBase64,
  toUint8Array,
  toUtf8,
  withBaseException
} from "./chunk-OIAWM4PQ.js";
import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// ../node_modules/@smithy/middleware-compression/dist-es/NODE_DISABLE_REQUEST_COMPRESSION_CONFIG_OPTIONS.js
var DEFAULT_DISABLE_REQUEST_COMPRESSION = false;

// ../node_modules/@smithy/middleware-compression/dist-es/NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES_CONFIG_OPTIONS.js
var DEFAULT_NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES = 10240;

// ../node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c2, id, msg, transfer, cb) {
  var w2 = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
    c2 + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w2.onmessage = function(e2) {
    var d2 = e2.data, ed = d2.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d2);
  };
  w2.postMessage(msg, transfer);
  return w2;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b3 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b3[i2] = start += 1 << eb[i2 - 1];
  }
  var r2 = new i32(b3[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b3[i2]; j2 < b3[i2 + 1]; ++j2) {
      r2[j2] = j2 - b3[i2] << 5 | i2;
    }
  }
  return { b: b3, r: r2 };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i2 = 0; i2 < 32768; ++i2) {
  x2 = (i2 & 43690) >> 1 | (i2 & 21845) << 1;
  x2 = (x2 & 52428) >> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >> 4 | (x2 & 3855) << 4;
  rev[i2] = ((x2 & 65280) >> 8 | (x2 & 255) << 8) >> 1;
}
var x2;
var i2;
var hMap = function(cd, mb, r2) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2) {
    if (cd[i2])
      ++l2[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1; i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le[cd[i2] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i2 = 0; i2 < 144; ++i2)
  flt[i2] = 8;
var i2;
for (i2 = 144; i2 < 256; ++i2)
  flt[i2] = 9;
var i2;
for (i2 = 256; i2 < 280; ++i2)
  flt[i2] = 7;
var i2;
for (i2 = 280; i2 < 288; ++i2)
  flt[i2] = 8;
var i2;
var fdt = new u8(32);
for (i2 = 0; i2 < 32; ++i2)
  fdt[i2] = 5;
var i2;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a2) {
  var m2 = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m2)
      m2 = a2[i2];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
};
var shft = function(p2) {
  return (p2 + 7) / 8 | 0;
};
var slc = function(v2, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  return new u8(v2.subarray(s2, e2));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e2 = new Error(msg || ec[ind]);
  e2.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e2, err);
  if (!nt)
    throw e2;
  return e2;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l2);
        buf.set(dat.subarray(s2, t2), bt);
        st.b = bt += l2, st.p = pos = t2 * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c2;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
      pos += c2 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c2)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b3 = fleb[i2];
          add = bits(dat, pos, (1 << b3) - 1) + fl[i2];
          pos += b3;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err(3);
        pos += d2 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b3 = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b3) - 1, pos += b3;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var wbits = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
};
var wbits16 = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
  d2[o2 + 2] |= v2 >> 16;
};
var hTree = function(d2, mb) {
  var t2 = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t2.push({ s: i2, f: d2[i2] });
  }
  var s2 = t2.length;
  var t22 = t2.slice();
  if (!s2)
    return { t: et, l: 0 };
  if (s2 == 1) {
    var v2 = new u8(t2[0].s + 1);
    v2[t2[0].s] = 1;
    return { t: v2, l: 1 };
  }
  t2.sort(function(a2, b3) {
    return a2.f - b3.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l2 = t2[0], r2 = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  while (i1 != s2 - 1) {
    l2 = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r2 = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b3) {
      return tr[b3.s] - tr[a2.s] || a2.f - b3.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c2[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i2];
    }
  }
  return { c: cl.subarray(0, cli), n: s2 };
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
  wbits(out, p2++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    ++lcfreq[lclt[i2] & 31];
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    ++lcfreq[lcdt[i2] & 31];
  var _e2 = hTree(lcfreq, 7), lct = _e2.t, mlcb = _e2.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p2 + 3 * i2, lct[clim[i2]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i2] >> 5 & 127), p2 += clct[i2] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    var sym = syms[i2];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
      if (len > 7)
        wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
      var dst = sym & 31;
      wbits16(out, p2, dm[dst]), p2 += dl[dst];
      if (dst > 3)
        wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[sym]), p2 += ll[sym];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st) {
  var s2 = st.z || dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
  var w2 = o2.subarray(pre, o2.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w2[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n2 = opt >> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i2 + 2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
      syms[li++] = dat[i2];
      ++lf[dat[i2]];
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w2[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i2, st.w = wi;
    }
  } else {
    for (var i2 = st.w || 0; i2 < s2 + lst; i2 += 65535) {
      var e2 = i2 + 65535;
      if (e2 >= s2) {
        w2[pos / 8 | 0] = lst;
        e2 = s2;
      }
      pos = wfblk(w2, pos + 1, dat.subarray(i2, e2));
    }
    st.i = s2;
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var crct = function() {
  var t2 = new Int32Array(256);
  for (var i2 = 0; i2 < 256; ++i2) {
    var c2 = i2, k2 = 9;
    while (--k2)
      c2 = (c2 & 1 && -306674912) ^ c2 >>> 1;
    t2[i2] = c2;
  }
  return t2;
}();
var crc = function() {
  var c2 = -1;
  return {
    p: function(d2) {
      var cr = c2;
      for (var i2 = 0; i2 < d2.length; ++i2)
        cr = crct[cr & 255 ^ d2[i2]] ^ cr >>> 8;
      c2 = cr;
    },
    d: function() {
      return ~c2;
    }
  };
};
var adler = function() {
  var a2 = 1, b3 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b3;
      var l2 = d2.length | 0;
      for (var i2 = 0; i2 != l2; ) {
        var e2 = Math.min(i2 + 2655, l2);
        for (; i2 < e2; ++i2)
          m2 += n2 += d2[i2];
        n2 = (n2 & 65535) + 15 * (n2 >> 16), m2 = (m2 & 65535) + 15 * (m2 >> 16);
      }
      a2 = n2, b3 = m2;
    },
    d: function() {
      a2 %= 65521, b3 %= 65521;
      return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b3 & 255) << 8 | b3 >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, st);
};
var mrg = function(a2, b3) {
  var o2 = {};
  for (var k2 in a2)
    o2[k2] = a2[k2];
  for (var k2 in b3)
    o2[k2] = b3[k2];
  return o2;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i2 = 0; i2 < dt.length; ++i2) {
    var v2 = dt[i2], k2 = ks[i2];
    if (typeof v2 == "function") {
      fnStr += ";" + k2 + "=";
      var st_1 = v2.toString();
      if (v2.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t2 in v2.prototype)
            fnStr += ";" + k2 + ".prototype." + t2 + "=" + v2.prototype[t2].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k2] = v2;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v2) {
  var tl = [];
  for (var k2 in v2) {
    if (v2[k2].buffer) {
      tl.push((v2[k2] = new v2[k2].constructor(v2[k2])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init, id, cb) {
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m2 = fns.length - 1;
    for (var i2 = 0; i2 < m2; ++i2)
      fnStr = wcln(fns[i2], fnStr, td_1);
    ch[id] = { c: wcln(fns[m2], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id].e);
  return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var bDflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var gze = function() {
  return [gzh, gzhl, wbytes, crc, crct];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zls];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o2) {
  return o2 && {
    out: o2.size && new u8(o2.size),
    dictionary: o2.dictionary
  };
};
var cbify = function(dat, opts, fns, init, id, cb) {
  var w2 = wrkr(fns, init, id, function(err2, dat2) {
    w2.terminate();
    cb(err2, dat2);
  });
  w2.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
  return function() {
    w2.terminate();
  };
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    return strm.push(ev.data[0], ev.data[1]);
  };
};
var astrmify = function(fns, strm, opts, init, id, ext) {
  var t2;
  var w2 = wrkr(fns, init, id, function(err2, dat) {
    if (err2)
      w2.terminate(), strm.ondata.call(strm, err2);
    else if (!Array.isArray(dat))
      ext(dat);
    else {
      if (dat[1])
        w2.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w2.postMessage(opts);
  strm.push = function(d2, f2) {
    if (!strm.ondata)
      err(5);
    if (t2)
      strm.ondata(err(4, 0, 1), null, !!f2);
    w2.postMessage([d2, t2 = f2], [d2.buffer]);
  };
  strm.terminate = function() {
    w2.terminate();
  };
};
var b2 = function(d2, b3) {
  return d2[b3] | d2[b3 + 1] << 8;
};
var b4 = function(d2, b3) {
  return (d2[b3] | d2[b3 + 1] << 8 | d2[b3 + 2] << 16 | d2[b3 + 3] << 24) >>> 0;
};
var b8 = function(d2, b3) {
  return b4(d2, b3) + b4(d2, b3 + 4) * 4294967296;
};
var wbytes = function(d2, b3, v2) {
  for (; v2; ++b3)
    d2[b3] = v2, v2 >>>= 8;
};
var gzh = function(c2, o2) {
  var fn = o2.filename;
  c2[0] = 31, c2[1] = 139, c2[2] = 8, c2[8] = o2.level < 2 ? 4 : o2.level == 9 ? 2 : 0, c2[9] = 3;
  if (o2.mtime != 0)
    wbytes(c2, 4, Math.floor(new Date(o2.mtime || Date.now()) / 1e3));
  if (fn) {
    c2[3] = 8;
    for (var i2 = 0; i2 <= fn.length; ++i2)
      c2[i2 + 10] = fn.charCodeAt(i2);
  }
};
var gzs = function(d2) {
  if (d2[0] != 31 || d2[1] != 139 || d2[2] != 8)
    err(6, "invalid gzip data");
  var flg = d2[3];
  var st = 10;
  if (flg & 4)
    st += (d2[10] | d2[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d2[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d2) {
  var l2 = d2.length;
  return (d2[l2 - 4] | d2[l2 - 3] << 8 | d2[l2 - 2] << 16 | d2[l2 - 1] << 24) >>> 0;
};
var gzhl = function(o2) {
  return 10 + (o2.filename ? o2.filename.length + 1 : 0);
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (o2.dictionary && 32);
  c2[1] |= 31 - (c2[0] << 8 | c2[1]) % 31;
  if (o2.dictionary) {
    var h2 = adler();
    h2.p(o2.dictionary);
    wbytes(c2, 2, h2.d());
  }
};
var zls = function(d2, dict) {
  if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    err(6, "invalid zlib data");
  if ((d2[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d2[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
    this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
    this.b = new u8(98304);
    if (this.o.dictionary) {
      var dict = this.o.dictionary.subarray(-32768);
      this.b.set(dict, 32768 - dict.length);
      this.s.i = 32768 - dict.length;
    }
  }
  Deflate2.prototype.p = function(c2, f2) {
    this.ondata(dopt(c2, this.o, 0, 0, this.s), f2);
  };
  Deflate2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    var endLen = chunk.length + this.s.z;
    if (endLen > this.b.length) {
      if (endLen > 2 * this.b.length - 32768) {
        var newBuf = new u8(endLen & -32768);
        newBuf.set(this.b.subarray(0, this.s.z));
        this.b = newBuf;
      }
      var split = this.b.length - this.s.z;
      if (split) {
        this.b.set(chunk.subarray(0, split), this.s.z);
        this.s.z = this.b.length;
        this.p(this.b, false);
      }
      this.b.set(this.b.subarray(-32768));
      this.b.set(chunk.subarray(split), 32768);
      this.s.z = chunk.length - split + 32768;
      this.s.i = 32766, this.s.w = 32768;
    } else {
      this.b.set(chunk, this.s.z);
      this.s.z += chunk.length;
    }
    this.s.l = final & 1;
    if (this.s.z > this.s.w + 8191 || final) {
      this.p(this.b, final || false);
      this.s.w = this.s.i, this.s.i -= 2;
    }
  };
  return Deflate2;
}();
var AsyncDeflate = /* @__PURE__ */ function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c2) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c2;
    else if (c2.length) {
      var n2 = new u8(this.p.length + c2.length);
      n2.set(this.p), n2.set(c2, this.p.length), this.p = n2;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = /* @__PURE__ */ function() {
  function AsyncInflate2(opts, cb) {
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Inflate(ev.data);
      onmessage = astrm(strm);
    }, 7);
  }
  return AsyncInflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gzip = function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    this.l += chunk.length;
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip2.prototype.p = function(c2, f2) {
    var raw = dopt(c2, this.o, this.v && gzhl(this.o), f2 && 8, this.s);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f2)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f2);
  };
  return Gzip2;
}();
var AsyncGzip = /* @__PURE__ */ function() {
  function AsyncGzip2(opts, cb) {
    astrmify([
      bDflt,
      gze,
      function() {
        return [astrm, Deflate, Gzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gzip(ev.data);
      onmessage = astrm(strm);
    }, 8);
  }
  return AsyncGzip2;
}();
function gzip(data, opts, cb) {
  if (!cb)
    cb = opts, opts = {};
  if (typeof cb != "function")
    err(7);
  return cbify(data, opts, [
    bDflt,
    gze,
    function() {
      return [gzipSync];
    }
  ], function(ev) {
    return pbf(gzipSync(ev.data[0], ev.data[1]));
  }, 2, cb);
}
function gzipSync(data, opts) {
  if (!opts)
    opts = {};
  var c2 = crc(), l2 = data.length;
  c2.p(data);
  var d2 = dopt(data, opts, gzhl(opts), 8), s2 = d2.length;
  return gzh(d2, opts), wbytes(d2, s2 - 8, c2.d()), wbytes(d2, s2 - 4, l2), d2;
}
var Gunzip = function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p2 = this.p.subarray(this.v - 1);
      var s2 = p2.length > 3 ? gzs(p2) : 4;
      if (s2 > p2.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p2.length);
      }
      this.p = p2.subarray(s2), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      if (this.p.length)
        this.push(new u8(0), final);
    }
  };
  return Gunzip2;
}();
var AsyncGunzip = /* @__PURE__ */ function() {
  function AsyncGunzip2(opts, cb) {
    var _this_1 = this;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gunzip(ev.data);
      strm.onmember = function(offset) {
        return postMessage(offset);
      };
      onmessage = astrm(strm);
    }, 9, function(offset) {
      return _this_1.onmember && _this_1.onmember(offset);
    });
  }
  return AsyncGunzip2;
}();
var Zlib = function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib2.prototype.p = function(c2, f2) {
    var raw = dopt(c2, this.o, this.v && (this.o.dictionary ? 6 : 2), f2 && 4, this.s);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f2)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f2);
  };
  return Zlib2;
}();
var Unzlib = function() {
  function Unzlib2(opts, cb) {
    Inflate.call(this, opts, cb);
    this.v = opts && opts.dictionary ? 2 : 1;
  }
  Unzlib2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 6 && !final)
        return;
      this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = /* @__PURE__ */ function() {
  function AsyncUnzlib2(opts, cb) {
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Unzlib(ev.data);
      onmessage = astrm(strm);
    }, 11);
  }
  return AsyncUnzlib2;
}();
var Decompress = function() {
  function Decompress2(opts, cb) {
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
    this.o = StrmOpt.call(this, opts, cb) || {};
  }
  Decompress2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n2 = new u8(this.p.length + chunk.length);
        n2.set(this.p), n2.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        var _this_2 = this;
        var cb = function() {
          _this_2.ondata.apply(_this_2, arguments);
        };
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o, cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o, cb) : new this.Z(this.o, cb);
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(opts, cb) {
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
    Decompress.call(this, opts, cb);
  }
  AsyncDecompress2.prototype.push = function(chunk, final) {
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress2;
}();
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e2) {
}
var dutf8 = function(d2) {
  for (var r2 = "", i2 = 0; ; ) {
    var c2 = d2[i2++];
    var eb = (c2 > 127) + (c2 > 223) + (c2 > 239);
    if (i2 + eb > d2.length)
      return { s: r2, r: slc(d2, i2 - 1) };
    if (!eb)
      r2 += String.fromCharCode(c2);
    else if (eb == 3) {
      c2 = ((c2 & 15) << 18 | (d2[i2++] & 63) << 12 | (d2[i2++] & 63) << 6 | d2[i2++] & 63) - 65536, r2 += String.fromCharCode(55296 | c2 >> 10, 56320 | c2 & 1023);
    } else if (eb & 1)
      r2 += String.fromCharCode((c2 & 31) << 6 | d2[i2++] & 63);
    else
      r2 += String.fromCharCode((c2 & 15) << 12 | (d2[i2++] & 63) << 6 | d2[i2++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a2 = dutf8(dat), s2 = _a2.s, r2 = _a2.r;
    if (final) {
      if (r2.length)
        err(8);
      this.p = null;
    } else
      this.p = r2;
    this.ondata(s2, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i2 = 0; i2 < str.length; ++i2)
      ar_1[i2] = str.charCodeAt(i2);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l2 = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w2 = function(v2) {
    ar[ai++] = v2;
  };
  for (var i2 = 0; i2 < l2; ++i2) {
    if (ai + 5 > ar.length) {
      var n2 = new u8(ai + 8 + (l2 - i2 << 1));
      n2.set(ar);
      ar = n2;
    }
    var c2 = str.charCodeAt(i2);
    if (c2 < 128 || latin1)
      w2(c2);
    else if (c2 < 2048)
      w2(192 | c2 >> 6), w2(128 | c2 & 63);
    else if (c2 > 55295 && c2 < 57344)
      c2 = 65536 + (c2 & 1023 << 10) | str.charCodeAt(++i2) & 1023, w2(240 | c2 >> 18), w2(128 | c2 >> 12 & 63), w2(128 | c2 >> 6 & 63), w2(128 | c2 & 63);
    else
      w2(224 | c2 >> 12), w2(128 | c2 >> 6 & 63), w2(128 | c2 & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r2 = "";
    for (var i2 = 0; i2 < dat.length; i2 += 16384)
      r2 += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
    return r2;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s2 = _a2.s, r2 = _a2.r;
    if (r2.length)
      err(8);
    return s2;
  }
}
var dbf = function(l2) {
  return l2 == 1 ? 3 : l2 < 6 ? 2 : l2 == 9 ? 1 : 0;
};
var z64e = function(d2, b3) {
  for (; b2(d2, b3) != 1; b3 += 4 + b2(d2, b3 + 2))
    ;
  return [b8(d2, b3 + 12), b8(d2, b3 + 4), b8(d2, b3 + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k2 in ex) {
      var l2 = ex[k2].length;
      if (l2 > 65535)
        err(9);
      le += l2 + 4;
    }
  }
  return le;
};
var wzh = function(d2, b3, f2, fn, u2, c2, ce, co) {
  var fl2 = fn.length, ex = f2.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d2, b3, ce != null ? 33639248 : 67324752), b3 += 4;
  if (ce != null)
    d2[b3++] = 20, d2[b3++] = f2.os;
  d2[b3] = 20, b3 += 2;
  d2[b3++] = f2.flag << 1 | (c2 < 0 && 8), d2[b3++] = u2 && 8;
  d2[b3++] = f2.compression & 255, d2[b3++] = f2.compression >> 8;
  var dt = new Date(f2.mtime == null ? Date.now() : f2.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d2, b3, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b3 += 4;
  if (c2 != -1) {
    wbytes(d2, b3, f2.crc);
    wbytes(d2, b3 + 4, c2 < 0 ? -c2 - 2 : c2);
    wbytes(d2, b3 + 8, f2.size);
  }
  wbytes(d2, b3 + 12, fl2);
  wbytes(d2, b3 + 14, exl), b3 += 16;
  if (ce != null) {
    wbytes(d2, b3, col);
    wbytes(d2, b3 + 6, f2.attrs);
    wbytes(d2, b3 + 10, ce), b3 += 14;
  }
  d2.set(fn, b3);
  b3 += fl2;
  if (exl) {
    for (var k2 in ex) {
      var exf = ex[k2], l2 = exf.length;
      wbytes(d2, b3, +k2);
      wbytes(d2, b3 + 2, l2);
      d2.set(exf, b3 + 4), b3 += 4 + l2;
    }
  }
  if (col)
    d2.set(co, b3), b3 += col;
  return b3;
};
var wzf = function(o2, b3, c2, d2, e2) {
  wbytes(o2, b3, 101010256);
  wbytes(o2, b3 + 8, c2);
  wbytes(o2, b3 + 10, c2);
  wbytes(o2, b3 + 12, d2);
  wbytes(o2, b3 + 16, e2);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e2) {
      this.ondata(e2, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this_1 = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this_1.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate2;
}();
var Zip = function() {
  function Zip2(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this_1 = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f2 = strToU8(file.filename), fl_1 = f2.length;
      var com = file.comment, o2 = com && strToU8(com);
      var u2 = fl_1 != file.filename.length || o2 && com.length != o2.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u8(hl_1);
      wzh(header, 0, file, f2, u2, -1);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this_1.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f: f2,
        u: u2,
        o: o2,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this_1.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this_1.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this_1.ondata(err2, dat, final);
          _this_1.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u8(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip2.prototype.end = function() {
    var _this_1 = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this_1.d & 1))
            return;
          _this_1.u.splice(-1, 1);
          _this_1.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt = 0, l2 = 0, tl = 0;
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f2 = _a2[_i];
      tl += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f2 = _c[_b2];
      wzh(out, bt, f2, f2.f, f2.u, -f2.c - 2, l2, f2.o);
      bt += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0), l2 += f2.b;
    }
    wzf(out, bt, this.u.length, tl, l2);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f2 = _a2[_i];
      f2.t();
    }
    this.d = 2;
  };
  return Zip2;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this_1 = this;
    this.i = new Inflate(function(dat, final) {
      _this_1.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e2) {
      this.ondata(e2, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_2, sz) {
    var _this_1 = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this_1.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this_1.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk, final) {
    var _this_1 = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f2 = 0, i2 = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l2 = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a2;
        var sig = b4(buf, i2);
        if (sig == 67324752) {
          f2 = 1, is = i2;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i2 + 6), cmp_1 = b2(buf, i2 + 8), u2 = bf & 2048, dd = bf & 8, fnl = b2(buf, i2 + 26), es = b2(buf, i2 + 28);
          if (l2 > i2 + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f2 = 2;
            var sc_1 = b4(buf, i2 + 18), su_1 = b4(buf, i2 + 22);
            var fn_1 = strFromU8(buf.subarray(i2 + 30, i2 += 30 + fnl), !u2);
            if (sc_1 == 4294967295) {
              _a2 = dd ? [-2] : z64e(buf, i2), sc_1 = _a2[0], su_1 = _a2[1];
            } else if (dd)
              sc_1 = -1;
            i2 += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this_1.o[cmp_1];
                  if (!ctr)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this_1.k[0] == chks_3 && _this_1.c)
                    _this_1.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i2 += 12 + (oc == -2 && 8), f2 = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i2 -= 4, f2 = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i2 < l2 - 4; ++i2) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f2 ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i2);
        if (add)
          add.push(dat, !!f2);
        else
          this.k[+(f2 == 2)].push(dat);
      }
      if (f2 & 2)
        return this.push(buf.subarray(i2), final);
      this.p = buf.subarray(i2);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder) {
    this.o[decoder.compression] = decoder;
  };
  return Unzip2;
}();

// ../node_modules/@smithy/middleware-compression/dist-es/compressStream.browser.js
var compressStream = async (body) => {
  let endCallback;
  const asyncGzip = new AsyncGzip();
  const compressionStream = new TransformStream({
    start(controller) {
      asyncGzip.ondata = (err2, data, final) => {
        if (err2) {
          controller.error(err2);
        } else {
          controller.enqueue(data);
          if (final) {
            if (endCallback)
              endCallback();
            else
              controller.terminate();
          }
        }
      };
    },
    transform(chunk) {
      asyncGzip.push(chunk);
    },
    flush() {
      return new Promise((resolve) => {
        endCallback = resolve;
        asyncGzip.push(new Uint8Array(0), true);
      });
    }
  });
  return body.pipeThrough(compressionStream);
};

// ../node_modules/@smithy/middleware-compression/dist-es/compressString.browser.js
var compressString = async (body) => new Promise((resolve, reject) => {
  gzip(toUint8Array(body || ""), (err2, data) => {
    if (err2) {
      reject(new Error("Failure during compression: " + err2.message));
    } else {
      resolve(data);
    }
  });
});

// ../node_modules/@smithy/middleware-compression/dist-es/constants.js
var CompressionAlgorithm;
(function(CompressionAlgorithm2) {
  CompressionAlgorithm2["GZIP"] = "gzip";
})(CompressionAlgorithm || (CompressionAlgorithm = {}));
var CLIENT_SUPPORTED_ALGORITHMS = [CompressionAlgorithm.GZIP];

// ../node_modules/@smithy/middleware-compression/dist-es/isStreaming.js
var isStreaming = (body) => body !== void 0 && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer(body);

// ../node_modules/@smithy/middleware-compression/dist-es/compressionMiddleware.js
var compressionMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
  if (!HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const disableRequestCompression = await config.disableRequestCompression();
  if (disableRequestCompression) {
    return next(args);
  }
  const { request } = args;
  const { body, headers } = request;
  const { encodings, streamRequiresLength } = middlewareConfig;
  let updatedBody = body;
  let updatedHeaders = headers;
  for (const algorithm of encodings) {
    if (CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
      let isRequestCompressed = false;
      if (isStreaming(body)) {
        if (!streamRequiresLength) {
          updatedBody = await compressStream(body);
          isRequestCompressed = true;
        } else {
          throw new Error("Compression is not supported for streaming blobs that require a length.");
        }
      } else {
        const bodyLength = config.bodyLengthChecker(body);
        const requestMinCompressionSizeBytes = await config.requestMinCompressionSizeBytes();
        if (bodyLength && bodyLength >= requestMinCompressionSizeBytes) {
          updatedBody = await compressString(body);
          isRequestCompressed = true;
        }
      }
      if (isRequestCompressed) {
        if (headers["content-encoding"]) {
          updatedHeaders = {
            ...headers,
            "content-encoding": `${headers["content-encoding"]}, ${algorithm}`
          };
        } else {
          updatedHeaders = { ...headers, "content-encoding": algorithm };
        }
        if (updatedHeaders["content-encoding"].includes("gzip")) {
          setFeature(context, "GZIP_REQUEST_COMPRESSION", "L");
        }
        break;
      }
    }
  }
  return next({
    ...args,
    request: {
      ...request,
      body: updatedBody,
      headers: updatedHeaders
    }
  });
};
var compressionMiddlewareOptions = {
  name: "compressionMiddleware",
  step: "build",
  tags: ["REQUEST_BODY_COMPRESSION", "GZIP"],
  override: true,
  priority: "high"
};

// ../node_modules/@smithy/middleware-compression/dist-es/getCompressionPlugin.js
var getCompressionPlugin = (config, middlewareConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(compressionMiddleware(config, middlewareConfig), compressionMiddlewareOptions);
  }
});

// ../node_modules/@smithy/middleware-compression/dist-es/resolveCompressionConfig.js
var resolveCompressionConfig = (input) => ({
  ...input,
  disableRequestCompression: normalizeProvider(input.disableRequestCompression),
  requestMinCompressionSizeBytes: async () => {
    const requestMinCompressionSizeBytes = await normalizeProvider(input.requestMinCompressionSizeBytes)();
    if (requestMinCompressionSizeBytes < 0 || requestMinCompressionSizeBytes > 10485760) {
      throw new RangeError(`The value for requestMinCompressionSizeBytes must be between 0 and 10485760 inclusive. The provided value ${requestMinCompressionSizeBytes} is outside this range."`);
    }
    return requestMinCompressionSizeBytes;
  }
});

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/auth/httpAuthSchemeProvider.js
var defaultCloudWatchHttpAuthSchemeParametersProvider = async (config, context, input) => {
  return {
    operation: getSmithyContext(context).operation,
    region: await normalizeProvider(config.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "monitoring",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
var defaultCloudWatchHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
    }
  }
  return options;
};
var resolveHttpAuthSchemeConfig = (config) => {
  const config_0 = resolveAwsSdkSigV4Config(config);
  return {
    ...config_0
  };
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "monitoring"
  };
};
var commonParams = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};

// ../node_modules/@aws-sdk/client-cloudwatch/package.json
var package_default = {
  name: "@aws-sdk/client-cloudwatch",
  description: "AWS SDK for JavaScript Cloudwatch Client for Node.js, Browser and React Native",
  version: "3.726.1",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-cloudwatch",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo cloudwatch"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/client-sso-oidc": "3.726.0",
    "@aws-sdk/client-sts": "3.726.1",
    "@aws-sdk/core": "3.723.0",
    "@aws-sdk/credential-provider-node": "3.726.0",
    "@aws-sdk/middleware-host-header": "3.723.0",
    "@aws-sdk/middleware-logger": "3.723.0",
    "@aws-sdk/middleware-recursion-detection": "3.723.0",
    "@aws-sdk/middleware-user-agent": "3.726.0",
    "@aws-sdk/region-config-resolver": "3.723.0",
    "@aws-sdk/types": "3.723.0",
    "@aws-sdk/util-endpoints": "3.726.0",
    "@aws-sdk/util-user-agent-browser": "3.723.0",
    "@aws-sdk/util-user-agent-node": "3.726.0",
    "@smithy/config-resolver": "^4.0.0",
    "@smithy/core": "^3.0.0",
    "@smithy/fetch-http-handler": "^5.0.0",
    "@smithy/hash-node": "^4.0.0",
    "@smithy/invalid-dependency": "^4.0.0",
    "@smithy/middleware-compression": "^4.0.0",
    "@smithy/middleware-content-length": "^4.0.0",
    "@smithy/middleware-endpoint": "^4.0.0",
    "@smithy/middleware-retry": "^4.0.0",
    "@smithy/middleware-serde": "^4.0.0",
    "@smithy/middleware-stack": "^4.0.0",
    "@smithy/node-config-provider": "^4.0.0",
    "@smithy/node-http-handler": "^4.0.0",
    "@smithy/protocol-http": "^5.0.0",
    "@smithy/smithy-client": "^4.0.0",
    "@smithy/types": "^4.0.0",
    "@smithy/url-parser": "^4.0.0",
    "@smithy/util-base64": "^4.0.0",
    "@smithy/util-body-length-browser": "^4.0.0",
    "@smithy/util-body-length-node": "^4.0.0",
    "@smithy/util-defaults-mode-browser": "^4.0.0",
    "@smithy/util-defaults-mode-node": "^4.0.0",
    "@smithy/util-endpoints": "^3.0.0",
    "@smithy/util-middleware": "^4.0.0",
    "@smithy/util-retry": "^4.0.0",
    "@smithy/util-utf8": "^4.0.0",
    "@smithy/util-waiter": "^4.0.0",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@tsconfig/node18": "18.2.4",
    "@types/node": "^18.19.69",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~5.2.2"
  },
  engines: {
    node: ">=18.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cloudwatch",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-cloudwatch"
  }
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/ruleset.js
var u = "required";
var v = "fn";
var w = "argv";
var x = "ref";
var a = true;
var b = "isSet";
var c = "booleanEquals";
var d = "error";
var e = "endpoint";
var f = "tree";
var g = "PartitionResult";
var h = "getAttr";
var i = { [u]: false, "type": "String" };
var j = { [u]: true, "default": false, "type": "Boolean" };
var k = { [x]: "Endpoint" };
var l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] };
var m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] };
var n = {};
var o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] };
var p = { [x]: g };
var q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
var r = [l];
var s = [m];
var t = [{ [x]: "Region" }];
var _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://monitoring-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://monitoring.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://monitoring-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://monitoring.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://monitoring.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
var ruleSet = _data;

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/endpointResolver.js
var cache = new EndpointCache({
  size: 50,
  params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
});
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return cache.get(endpointParams, () => resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  }));
};
customEndpointFunctions.aws = awsEndpointFunctions;

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = (config) => {
  return {
    apiVersion: "2010-08-01",
    base64Decoder: (config == null ? void 0 : config.base64Decoder) ?? fromBase64,
    base64Encoder: (config == null ? void 0 : config.base64Encoder) ?? toBase64,
    disableHostPrefix: (config == null ? void 0 : config.disableHostPrefix) ?? false,
    endpointProvider: (config == null ? void 0 : config.endpointProvider) ?? defaultEndpointResolver,
    extensions: (config == null ? void 0 : config.extensions) ?? [],
    httpAuthSchemeProvider: (config == null ? void 0 : config.httpAuthSchemeProvider) ?? defaultCloudWatchHttpAuthSchemeProvider,
    httpAuthSchemes: (config == null ? void 0 : config.httpAuthSchemes) ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new AwsSdkSigV4Signer()
      }
    ],
    logger: (config == null ? void 0 : config.logger) ?? new NoOpLogger(),
    serviceId: (config == null ? void 0 : config.serviceId) ?? "CloudWatch",
    urlParser: (config == null ? void 0 : config.urlParser) ?? parseUrl,
    utf8Decoder: (config == null ? void 0 : config.utf8Decoder) ?? fromUtf8,
    utf8Encoder: (config == null ? void 0 : config.utf8Encoder) ?? toUtf8
  };
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeConfig.browser.js
var getRuntimeConfig2 = (config) => {
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "browser",
    defaultsMode,
    bodyLengthChecker: (config == null ? void 0 : config.bodyLengthChecker) ?? calculateBodyLength,
    credentialDefaultProvider: (config == null ? void 0 : config.credentialDefaultProvider) ?? ((_2) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: (config == null ? void 0 : config.defaultUserAgentProvider) ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    disableRequestCompression: (config == null ? void 0 : config.disableRequestCompression) ?? DEFAULT_DISABLE_REQUEST_COMPRESSION,
    maxAttempts: (config == null ? void 0 : config.maxAttempts) ?? DEFAULT_MAX_ATTEMPTS,
    region: (config == null ? void 0 : config.region) ?? invalidProvider("Region is missing"),
    requestHandler: FetchHttpHandler.create((config == null ? void 0 : config.requestHandler) ?? defaultConfigProvider),
    requestMinCompressionSizeBytes: (config == null ? void 0 : config.requestMinCompressionSizeBytes) ?? DEFAULT_NODE_REQUEST_MIN_COMPRESSION_SIZE_BYTES,
    retryMode: (config == null ? void 0 : config.retryMode) ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
    sha256: (config == null ? void 0 : config.sha256) ?? Sha256,
    streamCollector: (config == null ? void 0 : config.streamCollector) ?? streamCollector,
    useDualstackEndpoint: (config == null ? void 0 : config.useDualstackEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
    useFipsEndpoint: (config == null ? void 0 : config.useFipsEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
  };
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
var resolveHttpAuthRuntimeConfig = (config) => {
  return {
    httpAuthSchemes: config.httpAuthSchemes(),
    httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
    credentials: config.credentials()
  };
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeExtensions.js
var asPartial = (t2) => t2;
var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
    ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
  };
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/CloudWatchClient.js
var CloudWatchClient = class extends Client {
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig2(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveUserAgentConfig(_config_1);
    const _config_3 = resolveRetryConfig(_config_2);
    const _config_4 = resolveRegionConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveEndpointConfig(_config_5);
    const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
    const _config_8 = resolveCompressionConfig(_config_7);
    const _config_9 = resolveRuntimeExtensions(_config_8, (configuration == null ? void 0 : configuration.extensions) || []);
    super(_config_9);
    __publicField(this, "config");
    this.config = _config_9;
    this.middlewareStack.use(getUserAgentPlugin(this.config));
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultCloudWatchHttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config.credentials
      })
    }));
    this.middlewareStack.use(getHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/models/CloudWatchServiceException.js
var CloudWatchServiceException = class _CloudWatchServiceException extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _CloudWatchServiceException.prototype);
  }
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/models/models_0.js
var ActionsSuppressedBy = {
  Alarm: "Alarm",
  ExtensionPeriod: "ExtensionPeriod",
  WaitPeriod: "WaitPeriod"
};
var AlarmType = {
  CompositeAlarm: "CompositeAlarm",
  MetricAlarm: "MetricAlarm"
};
var HistoryItemType = {
  Action: "Action",
  ConfigurationUpdate: "ConfigurationUpdate",
  StateUpdate: "StateUpdate"
};
var StandardUnit = {
  Bits: "Bits",
  Bits_Second: "Bits/Second",
  Bytes: "Bytes",
  Bytes_Second: "Bytes/Second",
  Count: "Count",
  Count_Second: "Count/Second",
  Gigabits: "Gigabits",
  Gigabits_Second: "Gigabits/Second",
  Gigabytes: "Gigabytes",
  Gigabytes_Second: "Gigabytes/Second",
  Kilobits: "Kilobits",
  Kilobits_Second: "Kilobits/Second",
  Kilobytes: "Kilobytes",
  Kilobytes_Second: "Kilobytes/Second",
  Megabits: "Megabits",
  Megabits_Second: "Megabits/Second",
  Megabytes: "Megabytes",
  Megabytes_Second: "Megabytes/Second",
  Microseconds: "Microseconds",
  Milliseconds: "Milliseconds",
  None: "None",
  Percent: "Percent",
  Seconds: "Seconds",
  Terabits: "Terabits",
  Terabits_Second: "Terabits/Second",
  Terabytes: "Terabytes",
  Terabytes_Second: "Terabytes/Second"
};
var AnomalyDetectorStateValue = {
  PENDING_TRAINING: "PENDING_TRAINING",
  TRAINED: "TRAINED",
  TRAINED_INSUFFICIENT_DATA: "TRAINED_INSUFFICIENT_DATA"
};
var AnomalyDetectorType = {
  METRIC_MATH: "METRIC_MATH",
  SINGLE_METRIC: "SINGLE_METRIC"
};
var ComparisonOperator = {
  GreaterThanOrEqualToThreshold: "GreaterThanOrEqualToThreshold",
  GreaterThanThreshold: "GreaterThanThreshold",
  GreaterThanUpperThreshold: "GreaterThanUpperThreshold",
  LessThanLowerOrGreaterThanUpperThreshold: "LessThanLowerOrGreaterThanUpperThreshold",
  LessThanLowerThreshold: "LessThanLowerThreshold",
  LessThanOrEqualToThreshold: "LessThanOrEqualToThreshold",
  LessThanThreshold: "LessThanThreshold"
};
var StateValue = {
  ALARM: "ALARM",
  INSUFFICIENT_DATA: "INSUFFICIENT_DATA",
  OK: "OK"
};
var ConcurrentModificationException = class _ConcurrentModificationException extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "ConcurrentModificationException",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "ConcurrentModificationException");
    __publicField(this, "$fault", "client");
    __publicField(this, "Message");
    Object.setPrototypeOf(this, _ConcurrentModificationException.prototype);
    this.Message = opts.Message;
  }
};
var DashboardInvalidInputError = class _DashboardInvalidInputError extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "DashboardInvalidInputError",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "DashboardInvalidInputError");
    __publicField(this, "$fault", "client");
    __publicField(this, "dashboardValidationMessages");
    Object.setPrototypeOf(this, _DashboardInvalidInputError.prototype);
    this.dashboardValidationMessages = opts.dashboardValidationMessages;
  }
};
var DashboardNotFoundError = class _DashboardNotFoundError extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "DashboardNotFoundError",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "DashboardNotFoundError");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _DashboardNotFoundError.prototype);
  }
};
var ResourceNotFound = class _ResourceNotFound extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFound",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "ResourceNotFound");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _ResourceNotFound.prototype);
  }
};
var InternalServiceFault = class _InternalServiceFault extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "InternalServiceFault",
      $fault: "server",
      ...opts
    });
    __publicField(this, "name", "InternalServiceFault");
    __publicField(this, "$fault", "server");
    __publicField(this, "Message");
    Object.setPrototypeOf(this, _InternalServiceFault.prototype);
    this.Message = opts.Message;
  }
};
var InvalidParameterCombinationException = class _InvalidParameterCombinationException extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "InvalidParameterCombinationException",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "InvalidParameterCombinationException");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _InvalidParameterCombinationException.prototype);
  }
};
var InvalidParameterValueException = class _InvalidParameterValueException extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "InvalidParameterValueException",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "InvalidParameterValueException");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _InvalidParameterValueException.prototype);
  }
};
var MissingRequiredParameterException = class _MissingRequiredParameterException extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "MissingRequiredParameterException",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "MissingRequiredParameterException");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _MissingRequiredParameterException.prototype);
  }
};
var ResourceNotFoundException = class _ResourceNotFoundException extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "ResourceNotFoundException");
    __publicField(this, "$fault", "client");
    __publicField(this, "ResourceType");
    __publicField(this, "ResourceId");
    __publicField(this, "Message");
    Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
    this.ResourceType = opts.ResourceType;
    this.ResourceId = opts.ResourceId;
    this.Message = opts.Message;
  }
};
var ScanBy = {
  TIMESTAMP_ASCENDING: "TimestampAscending",
  TIMESTAMP_DESCENDING: "TimestampDescending"
};
var InvalidNextToken = class _InvalidNextToken extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "InvalidNextToken",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "InvalidNextToken");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _InvalidNextToken.prototype);
  }
};
var EvaluationState = {
  PARTIAL_DATA: "PARTIAL_DATA"
};
var Statistic = {
  Average: "Average",
  Maximum: "Maximum",
  Minimum: "Minimum",
  SampleCount: "SampleCount",
  Sum: "Sum"
};
var LimitExceededException = class _LimitExceededException extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "LimitExceededException");
    __publicField(this, "$fault", "client");
    __publicField(this, "Message");
    Object.setPrototypeOf(this, _LimitExceededException.prototype);
    this.Message = opts.Message;
  }
};
var StatusCode = {
  COMPLETE: "Complete",
  FORBIDDEN: "Forbidden",
  INTERNAL_ERROR: "InternalError",
  PARTIAL_DATA: "PartialData"
};
var MetricStreamOutputFormat = {
  JSON: "json",
  OPEN_TELEMETRY_0_7: "opentelemetry0.7",
  OPEN_TELEMETRY_1_0: "opentelemetry1.0"
};
var RecentlyActive = {
  PT3H: "PT3H"
};
var LimitExceededFault = class _LimitExceededFault extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "LimitExceededFault",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "LimitExceededFault");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _LimitExceededFault.prototype);
  }
};
var InvalidFormatFault = class _InvalidFormatFault extends CloudWatchServiceException {
  constructor(opts) {
    super({
      name: "InvalidFormatFault",
      $fault: "client",
      ...opts
    });
    __publicField(this, "name", "InvalidFormatFault");
    __publicField(this, "$fault", "client");
    Object.setPrototypeOf(this, _InvalidFormatFault.prototype);
  }
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/protocols/Aws_query.js
var se_DeleteAlarmsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteAlarmsInput(input, context),
    [_A]: _DA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteAnomalyDetectorCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteAnomalyDetectorInput(input, context),
    [_A]: _DAD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteDashboardsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteDashboardsInput(input, context),
    [_A]: _DD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteInsightRulesCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteInsightRulesInput(input, context),
    [_A]: _DIR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DeleteMetricStreamCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DeleteMetricStreamInput(input, context),
    [_A]: _DMS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeAlarmHistoryCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeAlarmHistoryInput(input, context),
    [_A]: _DAH,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeAlarmsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeAlarmsInput(input, context),
    [_A]: _DAe,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeAlarmsForMetricCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeAlarmsForMetricInput(input, context),
    [_A]: _DAFM,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeAnomalyDetectorsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeAnomalyDetectorsInput(input, context),
    [_A]: _DADe,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DescribeInsightRulesCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DescribeInsightRulesInput(input, context),
    [_A]: _DIRe,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DisableAlarmActionsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DisableAlarmActionsInput(input, context),
    [_A]: _DAA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_DisableInsightRulesCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_DisableInsightRulesInput(input, context),
    [_A]: _DIRi,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_EnableAlarmActionsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_EnableAlarmActionsInput(input, context),
    [_A]: _EAA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_EnableInsightRulesCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_EnableInsightRulesInput(input, context),
    [_A]: _EIR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetDashboardCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetDashboardInput(input, context),
    [_A]: _GD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetInsightRuleReportCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetInsightRuleReportInput(input, context),
    [_A]: _GIRR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetMetricDataCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetMetricDataInput(input, context),
    [_A]: _GMD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetMetricStatisticsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetMetricStatisticsInput(input, context),
    [_A]: _GMS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetMetricStreamCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetMetricStreamInput(input, context),
    [_A]: _GMSe,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_GetMetricWidgetImageCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_GetMetricWidgetImageInput(input, context),
    [_A]: _GMWI,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListDashboardsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListDashboardsInput(input, context),
    [_A]: _LD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListManagedInsightRulesCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListManagedInsightRulesInput(input, context),
    [_A]: _LMIR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListMetricsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListMetricsInput(input, context),
    [_A]: _LM,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListMetricStreamsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListMetricStreamsInput(input, context),
    [_A]: _LMS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_ListTagsForResourceCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_ListTagsForResourceInput(input, context),
    [_A]: _LTFR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutAnomalyDetectorCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutAnomalyDetectorInput(input, context),
    [_A]: _PAD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutCompositeAlarmCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutCompositeAlarmInput(input, context),
    [_A]: _PCA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutDashboardCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutDashboardInput(input, context),
    [_A]: _PD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutInsightRuleCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutInsightRuleInput(input, context),
    [_A]: _PIR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutManagedInsightRulesCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutManagedInsightRulesInput(input, context),
    [_A]: _PMIR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutMetricAlarmCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutMetricAlarmInput(input, context),
    [_A]: _PMA,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutMetricDataCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutMetricDataInput(input, context),
    [_A]: _PMD,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_PutMetricStreamCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_PutMetricStreamInput(input, context),
    [_A]: _PMS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_SetAlarmStateCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_SetAlarmStateInput(input, context),
    [_A]: _SAS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StartMetricStreamsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_StartMetricStreamsInput(input, context),
    [_A]: _SMS,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_StopMetricStreamsCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_StopMetricStreamsInput(input, context),
    [_A]: _SMSt,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_TagResourceCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_TagResourceInput(input, context),
    [_A]: _TR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var se_UntagResourceCommand = async (input, context) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_UntagResourceInput(input, context),
    [_A]: _UR,
    [_V]: _
  });
  return buildHttpRpcRequest(context, headers, "/", void 0, body);
};
var de_DeleteAlarmsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
};
var de_DeleteAnomalyDetectorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DeleteAnomalyDetectorOutput(data.DeleteAnomalyDetectorResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteDashboardsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DeleteDashboardsOutput(data.DeleteDashboardsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteInsightRulesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DeleteInsightRulesOutput(data.DeleteInsightRulesResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DeleteMetricStreamCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DeleteMetricStreamOutput(data.DeleteMetricStreamResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeAlarmHistoryCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DescribeAlarmHistoryOutput(data.DescribeAlarmHistoryResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeAlarmsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DescribeAlarmsOutput(data.DescribeAlarmsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeAlarmsForMetricCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DescribeAlarmsForMetricOutput(data.DescribeAlarmsForMetricResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeAnomalyDetectorsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DescribeAnomalyDetectorsOutput(data.DescribeAnomalyDetectorsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DescribeInsightRulesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DescribeInsightRulesOutput(data.DescribeInsightRulesResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_DisableAlarmActionsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
};
var de_DisableInsightRulesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_DisableInsightRulesOutput(data.DisableInsightRulesResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_EnableAlarmActionsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
};
var de_EnableInsightRulesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_EnableInsightRulesOutput(data.EnableInsightRulesResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetDashboardCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_GetDashboardOutput(data.GetDashboardResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetInsightRuleReportCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_GetInsightRuleReportOutput(data.GetInsightRuleReportResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetMetricDataCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_GetMetricDataOutput(data.GetMetricDataResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetMetricStatisticsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_GetMetricStatisticsOutput(data.GetMetricStatisticsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetMetricStreamCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_GetMetricStreamOutput(data.GetMetricStreamResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_GetMetricWidgetImageCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_GetMetricWidgetImageOutput(data.GetMetricWidgetImageResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListDashboardsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_ListDashboardsOutput(data.ListDashboardsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListManagedInsightRulesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_ListManagedInsightRulesOutput(data.ListManagedInsightRulesResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListMetricsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_ListMetricsOutput(data.ListMetricsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListMetricStreamsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_ListMetricStreamsOutput(data.ListMetricStreamsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_ListTagsForResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_ListTagsForResourceOutput(data.ListTagsForResourceResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_PutAnomalyDetectorCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_PutAnomalyDetectorOutput(data.PutAnomalyDetectorResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_PutCompositeAlarmCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
};
var de_PutDashboardCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_PutDashboardOutput(data.PutDashboardResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_PutInsightRuleCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_PutInsightRuleOutput(data.PutInsightRuleResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_PutManagedInsightRulesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_PutManagedInsightRulesOutput(data.PutManagedInsightRulesResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_PutMetricAlarmCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
};
var de_PutMetricDataCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
};
var de_PutMetricStreamCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_PutMetricStreamOutput(data.PutMetricStreamResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_SetAlarmStateCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
};
var de_StartMetricStreamsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_StartMetricStreamsOutput(data.StartMetricStreamsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_StopMetricStreamsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_StopMetricStreamsOutput(data.StopMetricStreamsResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_TagResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_TagResourceOutput(data.TagResourceResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_UntagResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await parseXmlBody(output.body, context);
  let contents = {};
  contents = de_UntagResourceOutput(data.UntagResourceResult, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
};
var de_CommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseXmlErrorBody(output.body, context)
  };
  const errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.cloudwatch#ResourceNotFound":
      throw await de_ResourceNotFoundRes(parsedOutput, context);
    case "InternalServiceError":
    case "com.amazonaws.cloudwatch#InternalServiceFault":
      throw await de_InternalServiceFaultRes(parsedOutput, context);
    case "InvalidParameterCombination":
    case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
      throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
    case "InvalidParameterValue":
    case "com.amazonaws.cloudwatch#InvalidParameterValueException":
      throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
    case "MissingParameter":
    case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
      throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.cloudwatch#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "InvalidNextToken":
    case "com.amazonaws.cloudwatch#InvalidNextToken":
      throw await de_InvalidNextTokenRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.cloudwatch#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "LimitExceeded":
    case "com.amazonaws.cloudwatch#LimitExceededFault":
      throw await de_LimitExceededFaultRes(parsedOutput, context);
    case "InvalidParameterInput":
    case "com.amazonaws.cloudwatch#DashboardInvalidInputError":
      throw await de_DashboardInvalidInputErrorRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.cloudwatch#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "InvalidFormat":
    case "com.amazonaws.cloudwatch#InvalidFormatFault":
      throw await de_InvalidFormatFaultRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
};
var de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ConcurrentModificationException(body.Error, context);
  const exception = new ConcurrentModificationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_DashboardInvalidInputErrorRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_DashboardInvalidInputError(body.Error, context);
  const exception = new DashboardInvalidInputError({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InternalServiceFaultRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InternalServiceFault(body.Error, context);
  const exception = new InternalServiceFault({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidFormatFaultRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidFormatFault(body.Error, context);
  const exception = new InvalidFormatFault({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidNextTokenRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidNextToken(body.Error, context);
  const exception = new InvalidNextToken({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidParameterCombinationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidParameterCombinationException(body.Error, context);
  const exception = new InvalidParameterCombinationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidParameterValueException(body.Error, context);
  const exception = new InvalidParameterValueException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_LimitExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_LimitExceededException(body.Error, context);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_LimitExceededFaultRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_LimitExceededFault(body.Error, context);
  const exception = new LimitExceededFault({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_MissingRequiredParameterExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_MissingRequiredParameterException(body.Error, context);
  const exception = new MissingRequiredParameterException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ResourceNotFoundRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ResourceNotFound(body.Error, context);
  const exception = new ResourceNotFound({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ResourceNotFoundException(body.Error, context);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
};
var se_AlarmNames = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_AlarmTypes = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_AnomalyDetectorConfiguration = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_ETR] != null) {
    const memberEntries = se_AnomalyDetectorExcludedTimeRanges(input[_ETR], context);
    if (((_a2 = input[_ETR]) == null ? void 0 : _a2.length) === 0) {
      entries.ExcludedTimeRanges = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExcludedTimeRanges.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_MT] != null) {
    entries[_MT] = input[_MT];
  }
  return entries;
};
var se_AnomalyDetectorExcludedTimeRanges = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_Range(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_AnomalyDetectorTypes = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_Counts = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = serializeFloat(entry);
    counter++;
  }
  return entries;
};
var se_DashboardNames = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_DeleteAlarmsInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_AN] != null) {
    const memberEntries = se_AlarmNames(input[_AN], context);
    if (((_a2 = input[_AN]) == null ? void 0 : _a2.length) === 0) {
      entries.AlarmNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DeleteAnomalyDetectorInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_S] != null) {
    entries[_S] = input[_S];
  }
  if (input[_SMAD] != null) {
    const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SingleMetricAnomalyDetector.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_MMAD] != null) {
    const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricMathAnomalyDetector.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DeleteDashboardsInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_DN] != null) {
    const memberEntries = se_DashboardNames(input[_DN], context);
    if (((_a2 = input[_DN]) == null ? void 0 : _a2.length) === 0) {
      entries.DashboardNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DashboardNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DeleteInsightRulesInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_RN] != null) {
    const memberEntries = se_InsightRuleNames(input[_RN], context);
    if (((_a2 = input[_RN]) == null ? void 0 : _a2.length) === 0) {
      entries.RuleNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RuleNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DeleteMetricStreamInput = (input, context) => {
  const entries = {};
  if (input[_Na] != null) {
    entries[_Na] = input[_Na];
  }
  return entries;
};
var se_DescribeAlarmHistoryInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_ANl] != null) {
    entries[_ANl] = input[_ANl];
  }
  if (input[_AT] != null) {
    const memberEntries = se_AlarmTypes(input[_AT], context);
    if (((_a2 = input[_AT]) == null ? void 0 : _a2.length) === 0) {
      entries.AlarmTypes = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmTypes.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_HIT] != null) {
    entries[_HIT] = input[_HIT];
  }
  if (input[_SD] != null) {
    entries[_SD] = serializeDateTime(input[_SD]);
  }
  if (input[_ED] != null) {
    entries[_ED] = serializeDateTime(input[_ED]);
  }
  if (input[_MR] != null) {
    entries[_MR] = input[_MR];
  }
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  if (input[_SB] != null) {
    entries[_SB] = input[_SB];
  }
  return entries;
};
var se_DescribeAlarmsForMetricInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_St] != null) {
    entries[_St] = input[_St];
  }
  if (input[_ES] != null) {
    entries[_ES] = input[_ES];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_U] != null) {
    entries[_U] = input[_U];
  }
  return entries;
};
var se_DescribeAlarmsInput = (input, context) => {
  var _a2, _b2;
  const entries = {};
  if (input[_AN] != null) {
    const memberEntries = se_AlarmNames(input[_AN], context);
    if (((_a2 = input[_AN]) == null ? void 0 : _a2.length) === 0) {
      entries.AlarmNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmNames.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_ANP] != null) {
    entries[_ANP] = input[_ANP];
  }
  if (input[_AT] != null) {
    const memberEntries = se_AlarmTypes(input[_AT], context);
    if (((_b2 = input[_AT]) == null ? void 0 : _b2.length) === 0) {
      entries.AlarmTypes = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmTypes.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_COAN] != null) {
    entries[_COAN] = input[_COAN];
  }
  if (input[_POAN] != null) {
    entries[_POAN] = input[_POAN];
  }
  if (input[_SV] != null) {
    entries[_SV] = input[_SV];
  }
  if (input[_AP] != null) {
    entries[_AP] = input[_AP];
  }
  if (input[_MR] != null) {
    entries[_MR] = input[_MR];
  }
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  return entries;
};
var se_DescribeAnomalyDetectorsInput = (input, context) => {
  var _a2, _b2;
  const entries = {};
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  if (input[_MRa] != null) {
    entries[_MRa] = input[_MRa];
  }
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_ADT] != null) {
    const memberEntries = se_AnomalyDetectorTypes(input[_ADT], context);
    if (((_b2 = input[_ADT]) == null ? void 0 : _b2.length) === 0) {
      entries.AnomalyDetectorTypes = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AnomalyDetectorTypes.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DescribeInsightRulesInput = (input, context) => {
  const entries = {};
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  if (input[_MRa] != null) {
    entries[_MRa] = input[_MRa];
  }
  return entries;
};
var se_Dimension = (input, context) => {
  const entries = {};
  if (input[_Na] != null) {
    entries[_Na] = input[_Na];
  }
  if (input[_Va] != null) {
    entries[_Va] = input[_Va];
  }
  return entries;
};
var se_DimensionFilter = (input, context) => {
  const entries = {};
  if (input[_Na] != null) {
    entries[_Na] = input[_Na];
  }
  if (input[_Va] != null) {
    entries[_Va] = input[_Va];
  }
  return entries;
};
var se_DimensionFilters = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_DimensionFilter(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_Dimensions = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_Dimension(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_DisableAlarmActionsInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_AN] != null) {
    const memberEntries = se_AlarmNames(input[_AN], context);
    if (((_a2 = input[_AN]) == null ? void 0 : _a2.length) === 0) {
      entries.AlarmNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_DisableInsightRulesInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_RN] != null) {
    const memberEntries = se_InsightRuleNames(input[_RN], context);
    if (((_a2 = input[_RN]) == null ? void 0 : _a2.length) === 0) {
      entries.RuleNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RuleNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_EnableAlarmActionsInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_AN] != null) {
    const memberEntries = se_AlarmNames(input[_AN], context);
    if (((_a2 = input[_AN]) == null ? void 0 : _a2.length) === 0) {
      entries.AlarmNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_EnableInsightRulesInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_RN] != null) {
    const memberEntries = se_InsightRuleNames(input[_RN], context);
    if (((_a2 = input[_RN]) == null ? void 0 : _a2.length) === 0) {
      entries.RuleNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RuleNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_Entity = (input, context) => {
  const entries = {};
  if (input[_KA] != null) {
    const memberEntries = se_EntityKeyAttributesMap(input[_KA], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `KeyAttributes.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_At] != null) {
    const memberEntries = se_EntityAttributesMap(input[_At], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Attributes.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_EntityAttributesMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.key`] = key;
    entries[`entry.${counter}.value`] = input[key];
    counter++;
  });
  return entries;
};
var se_EntityKeyAttributesMap = (input, context) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.key`] = key;
    entries[`entry.${counter}.value`] = input[key];
    counter++;
  });
  return entries;
};
var se_EntityMetricData = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_E] != null) {
    const memberEntries = se_Entity(input[_E], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Entity.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_MD] != null) {
    const memberEntries = se_MetricData(input[_MD], context);
    if (((_a2 = input[_MD]) == null ? void 0 : _a2.length) === 0) {
      entries.MetricData = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricData.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_EntityMetricDataList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_EntityMetricData(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_ExtendedStatistics = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_GetDashboardInput = (input, context) => {
  const entries = {};
  if (input[_DNa] != null) {
    entries[_DNa] = input[_DNa];
  }
  return entries;
};
var se_GetInsightRuleReportInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_RNu] != null) {
    entries[_RNu] = input[_RNu];
  }
  if (input[_ST] != null) {
    entries[_ST] = serializeDateTime(input[_ST]);
  }
  if (input[_ET] != null) {
    entries[_ET] = serializeDateTime(input[_ET]);
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_MCC] != null) {
    entries[_MCC] = input[_MCC];
  }
  if (input[_M] != null) {
    const memberEntries = se_InsightRuleMetricList(input[_M], context);
    if (((_a2 = input[_M]) == null ? void 0 : _a2.length) === 0) {
      entries.Metrics = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Metrics.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_OB] != null) {
    entries[_OB] = input[_OB];
  }
  return entries;
};
var se_GetMetricDataInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_MDQ] != null) {
    const memberEntries = se_MetricDataQueries(input[_MDQ], context);
    if (((_a2 = input[_MDQ]) == null ? void 0 : _a2.length) === 0) {
      entries.MetricDataQueries = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricDataQueries.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_ST] != null) {
    entries[_ST] = serializeDateTime(input[_ST]);
  }
  if (input[_ET] != null) {
    entries[_ET] = serializeDateTime(input[_ET]);
  }
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  if (input[_SB] != null) {
    entries[_SB] = input[_SB];
  }
  if (input[_MDa] != null) {
    entries[_MDa] = input[_MDa];
  }
  if (input[_LO] != null) {
    const memberEntries = se_LabelOptions(input[_LO], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LabelOptions.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_GetMetricStatisticsInput = (input, context) => {
  var _a2, _b2, _c;
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_ST] != null) {
    entries[_ST] = serializeDateTime(input[_ST]);
  }
  if (input[_ET] != null) {
    entries[_ET] = serializeDateTime(input[_ET]);
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_Sta] != null) {
    const memberEntries = se_Statistics(input[_Sta], context);
    if (((_b2 = input[_Sta]) == null ? void 0 : _b2.length) === 0) {
      entries.Statistics = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Statistics.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_ESx] != null) {
    const memberEntries = se_ExtendedStatistics(input[_ESx], context);
    if (((_c = input[_ESx]) == null ? void 0 : _c.length) === 0) {
      entries.ExtendedStatistics = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExtendedStatistics.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_U] != null) {
    entries[_U] = input[_U];
  }
  return entries;
};
var se_GetMetricStreamInput = (input, context) => {
  const entries = {};
  if (input[_Na] != null) {
    entries[_Na] = input[_Na];
  }
  return entries;
};
var se_GetMetricWidgetImageInput = (input, context) => {
  const entries = {};
  if (input[_MW] != null) {
    entries[_MW] = input[_MW];
  }
  if (input[_OF] != null) {
    entries[_OF] = input[_OF];
  }
  return entries;
};
var se_InsightRuleMetricList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_InsightRuleNames = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_LabelOptions = (input, context) => {
  const entries = {};
  if (input[_T] != null) {
    entries[_T] = input[_T];
  }
  return entries;
};
var se_ListDashboardsInput = (input, context) => {
  const entries = {};
  if (input[_DNP] != null) {
    entries[_DNP] = input[_DNP];
  }
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  return entries;
};
var se_ListManagedInsightRulesInput = (input, context) => {
  const entries = {};
  if (input[_RARN] != null) {
    entries[_RARN] = input[_RARN];
  }
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  if (input[_MRa] != null) {
    entries[_MRa] = input[_MRa];
  }
  return entries;
};
var se_ListMetricsInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_DimensionFilters(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  if (input[_RA] != null) {
    entries[_RA] = input[_RA];
  }
  if (input[_ILA] != null) {
    entries[_ILA] = input[_ILA];
  }
  if (input[_OA] != null) {
    entries[_OA] = input[_OA];
  }
  return entries;
};
var se_ListMetricStreamsInput = (input, context) => {
  const entries = {};
  if (input[_NT] != null) {
    entries[_NT] = input[_NT];
  }
  if (input[_MRa] != null) {
    entries[_MRa] = input[_MRa];
  }
  return entries;
};
var se_ListTagsForResourceInput = (input, context) => {
  const entries = {};
  if (input[_RARN] != null) {
    entries[_RARN] = input[_RARN];
  }
  return entries;
};
var se_ManagedRule = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_TN] != null) {
    entries[_TN] = input[_TN];
  }
  if (input[_RARN] != null) {
    entries[_RARN] = input[_RARN];
  }
  if (input[_Ta] != null) {
    const memberEntries = se_TagList(input[_Ta], context);
    if (((_a2 = input[_Ta]) == null ? void 0 : _a2.length) === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_ManagedRules = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_ManagedRule(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_Metric = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_MetricCharacteristics = (input, context) => {
  const entries = {};
  if (input[_PS] != null) {
    entries[_PS] = input[_PS];
  }
  return entries;
};
var se_MetricData = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_MetricDatum(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_MetricDataQueries = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_MetricDataQuery(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_MetricDataQuery = (input, context) => {
  const entries = {};
  if (input[_I] != null) {
    entries[_I] = input[_I];
  }
  if (input[_MS] != null) {
    const memberEntries = se_MetricStat(input[_MS], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricStat.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_Ex] != null) {
    entries[_Ex] = input[_Ex];
  }
  if (input[_L] != null) {
    entries[_L] = input[_L];
  }
  if (input[_RD] != null) {
    entries[_RD] = input[_RD];
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_AI] != null) {
    entries[_AI] = input[_AI];
  }
  return entries;
};
var se_MetricDatum = (input, context) => {
  var _a2, _b2, _c;
  const entries = {};
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_Ti] != null) {
    entries[_Ti] = serializeDateTime(input[_Ti]);
  }
  if (input[_Va] != null) {
    entries[_Va] = serializeFloat(input[_Va]);
  }
  if (input[_SVt] != null) {
    const memberEntries = se_StatisticSet(input[_SVt], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StatisticValues.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_Val] != null) {
    const memberEntries = se_Values(input[_Val], context);
    if (((_b2 = input[_Val]) == null ? void 0 : _b2.length) === 0) {
      entries.Values = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Values.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_C] != null) {
    const memberEntries = se_Counts(input[_C], context);
    if (((_c = input[_C]) == null ? void 0 : _c.length) === 0) {
      entries.Counts = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Counts.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_U] != null) {
    entries[_U] = input[_U];
  }
  if (input[_SR] != null) {
    entries[_SR] = input[_SR];
  }
  return entries;
};
var se_MetricMathAnomalyDetector = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_MDQ] != null) {
    const memberEntries = se_MetricDataQueries(input[_MDQ], context);
    if (((_a2 = input[_MDQ]) == null ? void 0 : _a2.length) === 0) {
      entries.MetricDataQueries = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricDataQueries.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_MetricStat = (input, context) => {
  const entries = {};
  if (input[_Me] != null) {
    const memberEntries = se_Metric(input[_Me], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Metric.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_S] != null) {
    entries[_S] = input[_S];
  }
  if (input[_U] != null) {
    entries[_U] = input[_U];
  }
  return entries;
};
var se_MetricStreamFilter = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MNe] != null) {
    const memberEntries = se_MetricStreamFilterMetricNames(input[_MNe], context);
    if (((_a2 = input[_MNe]) == null ? void 0 : _a2.length) === 0) {
      entries.MetricNames = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricNames.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_MetricStreamFilterMetricNames = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_MetricStreamFilters = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_MetricStreamFilter(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_MetricStreamNames = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_MetricStreamStatisticsAdditionalStatistics = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_MetricStreamStatisticsConfiguration = (input, context) => {
  var _a2, _b2;
  const entries = {};
  if (input[_IM] != null) {
    const memberEntries = se_MetricStreamStatisticsIncludeMetrics(input[_IM], context);
    if (((_a2 = input[_IM]) == null ? void 0 : _a2.length) === 0) {
      entries.IncludeMetrics = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IncludeMetrics.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_AS] != null) {
    const memberEntries = se_MetricStreamStatisticsAdditionalStatistics(input[_AS], context);
    if (((_b2 = input[_AS]) == null ? void 0 : _b2.length) === 0) {
      entries.AdditionalStatistics = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AdditionalStatistics.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_MetricStreamStatisticsConfigurations = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_MetricStreamStatisticsConfiguration(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_MetricStreamStatisticsIncludeMetrics = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_MetricStreamStatisticsMetric(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_MetricStreamStatisticsMetric = (input, context) => {
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  return entries;
};
var se_PutAnomalyDetectorInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_S] != null) {
    entries[_S] = input[_S];
  }
  if (input[_Co] != null) {
    const memberEntries = se_AnomalyDetectorConfiguration(input[_Co], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Configuration.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_MC] != null) {
    const memberEntries = se_MetricCharacteristics(input[_MC], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricCharacteristics.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_SMAD] != null) {
    const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SingleMetricAnomalyDetector.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_MMAD] != null) {
    const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricMathAnomalyDetector.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_PutCompositeAlarmInput = (input, context) => {
  var _a2, _b2, _c, _d;
  const entries = {};
  if (input[_AE] != null) {
    entries[_AE] = input[_AE];
  }
  if (input[_AA] != null) {
    const memberEntries = se_ResourceList(input[_AA], context);
    if (((_a2 = input[_AA]) == null ? void 0 : _a2.length) === 0) {
      entries.AlarmActions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmActions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_AD] != null) {
    entries[_AD] = input[_AD];
  }
  if (input[_ANl] != null) {
    entries[_ANl] = input[_ANl];
  }
  if (input[_AR] != null) {
    entries[_AR] = input[_AR];
  }
  if (input[_IDA] != null) {
    const memberEntries = se_ResourceList(input[_IDA], context);
    if (((_b2 = input[_IDA]) == null ? void 0 : _b2.length) === 0) {
      entries.InsufficientDataActions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InsufficientDataActions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_OKA] != null) {
    const memberEntries = se_ResourceList(input[_OKA], context);
    if (((_c = input[_OKA]) == null ? void 0 : _c.length) === 0) {
      entries.OKActions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `OKActions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_Ta] != null) {
    const memberEntries = se_TagList(input[_Ta], context);
    if (((_d = input[_Ta]) == null ? void 0 : _d.length) === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_ASc] != null) {
    entries[_ASc] = input[_ASc];
  }
  if (input[_ASWP] != null) {
    entries[_ASWP] = input[_ASWP];
  }
  if (input[_ASEP] != null) {
    entries[_ASEP] = input[_ASEP];
  }
  return entries;
};
var se_PutDashboardInput = (input, context) => {
  const entries = {};
  if (input[_DNa] != null) {
    entries[_DNa] = input[_DNa];
  }
  if (input[_DB] != null) {
    entries[_DB] = input[_DB];
  }
  return entries;
};
var se_PutInsightRuleInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_RNu] != null) {
    entries[_RNu] = input[_RNu];
  }
  if (input[_RS] != null) {
    entries[_RS] = input[_RS];
  }
  if (input[_RDu] != null) {
    entries[_RDu] = input[_RDu];
  }
  if (input[_Ta] != null) {
    const memberEntries = se_TagList(input[_Ta], context);
    if (((_a2 = input[_Ta]) == null ? void 0 : _a2.length) === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_PutManagedInsightRulesInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_MRan] != null) {
    const memberEntries = se_ManagedRules(input[_MRan], context);
    if (((_a2 = input[_MRan]) == null ? void 0 : _a2.length) === 0) {
      entries.ManagedRules = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ManagedRules.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_PutMetricAlarmInput = (input, context) => {
  var _a2, _b2, _c, _d, _e2, _f;
  const entries = {};
  if (input[_ANl] != null) {
    entries[_ANl] = input[_ANl];
  }
  if (input[_AD] != null) {
    entries[_AD] = input[_AD];
  }
  if (input[_AE] != null) {
    entries[_AE] = input[_AE];
  }
  if (input[_OKA] != null) {
    const memberEntries = se_ResourceList(input[_OKA], context);
    if (((_a2 = input[_OKA]) == null ? void 0 : _a2.length) === 0) {
      entries.OKActions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `OKActions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_AA] != null) {
    const memberEntries = se_ResourceList(input[_AA], context);
    if (((_b2 = input[_AA]) == null ? void 0 : _b2.length) === 0) {
      entries.AlarmActions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AlarmActions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_IDA] != null) {
    const memberEntries = se_ResourceList(input[_IDA], context);
    if (((_c = input[_IDA]) == null ? void 0 : _c.length) === 0) {
      entries.InsufficientDataActions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InsufficientDataActions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_St] != null) {
    entries[_St] = input[_St];
  }
  if (input[_ES] != null) {
    entries[_ES] = input[_ES];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_d = input[_D]) == null ? void 0 : _d.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_P] != null) {
    entries[_P] = input[_P];
  }
  if (input[_U] != null) {
    entries[_U] = input[_U];
  }
  if (input[_EP] != null) {
    entries[_EP] = input[_EP];
  }
  if (input[_DTA] != null) {
    entries[_DTA] = input[_DTA];
  }
  if (input[_Th] != null) {
    entries[_Th] = serializeFloat(input[_Th]);
  }
  if (input[_CO] != null) {
    entries[_CO] = input[_CO];
  }
  if (input[_TMD] != null) {
    entries[_TMD] = input[_TMD];
  }
  if (input[_ELSCP] != null) {
    entries[_ELSCP] = input[_ELSCP];
  }
  if (input[_M] != null) {
    const memberEntries = se_MetricDataQueries(input[_M], context);
    if (((_e2 = input[_M]) == null ? void 0 : _e2.length) === 0) {
      entries.Metrics = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Metrics.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_Ta] != null) {
    const memberEntries = se_TagList(input[_Ta], context);
    if (((_f = input[_Ta]) == null ? void 0 : _f.length) === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_TMI] != null) {
    entries[_TMI] = input[_TMI];
  }
  return entries;
};
var se_PutMetricDataInput = (input, context) => {
  var _a2, _b2;
  const entries = {};
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MD] != null) {
    const memberEntries = se_MetricData(input[_MD], context);
    if (((_a2 = input[_MD]) == null ? void 0 : _a2.length) === 0) {
      entries.MetricData = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetricData.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_EMD] != null) {
    const memberEntries = se_EntityMetricDataList(input[_EMD], context);
    if (((_b2 = input[_EMD]) == null ? void 0 : _b2.length) === 0) {
      entries.EntityMetricData = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EntityMetricData.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_SEV] != null) {
    entries[_SEV] = input[_SEV];
  }
  return entries;
};
var se_PutMetricStreamInput = (input, context) => {
  var _a2, _b2, _c, _d;
  const entries = {};
  if (input[_Na] != null) {
    entries[_Na] = input[_Na];
  }
  if (input[_IF] != null) {
    const memberEntries = se_MetricStreamFilters(input[_IF], context);
    if (((_a2 = input[_IF]) == null ? void 0 : _a2.length) === 0) {
      entries.IncludeFilters = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IncludeFilters.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_EF] != null) {
    const memberEntries = se_MetricStreamFilters(input[_EF], context);
    if (((_b2 = input[_EF]) == null ? void 0 : _b2.length) === 0) {
      entries.ExcludeFilters = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExcludeFilters.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_FA] != null) {
    entries[_FA] = input[_FA];
  }
  if (input[_RAo] != null) {
    entries[_RAo] = input[_RAo];
  }
  if (input[_OF] != null) {
    entries[_OF] = input[_OF];
  }
  if (input[_Ta] != null) {
    const memberEntries = se_TagList(input[_Ta], context);
    if (((_c = input[_Ta]) == null ? void 0 : _c.length) === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_SC] != null) {
    const memberEntries = se_MetricStreamStatisticsConfigurations(input[_SC], context);
    if (((_d = input[_SC]) == null ? void 0 : _d.length) === 0) {
      entries.StatisticsConfigurations = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StatisticsConfigurations.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_ILAM] != null) {
    entries[_ILAM] = input[_ILAM];
  }
  return entries;
};
var se_Range = (input, context) => {
  const entries = {};
  if (input[_ST] != null) {
    entries[_ST] = serializeDateTime(input[_ST]);
  }
  if (input[_ET] != null) {
    entries[_ET] = serializeDateTime(input[_ET]);
  }
  return entries;
};
var se_ResourceList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_SetAlarmStateInput = (input, context) => {
  const entries = {};
  if (input[_ANl] != null) {
    entries[_ANl] = input[_ANl];
  }
  if (input[_SV] != null) {
    entries[_SV] = input[_SV];
  }
  if (input[_SRt] != null) {
    entries[_SRt] = input[_SRt];
  }
  if (input[_SRD] != null) {
    entries[_SRD] = input[_SRD];
  }
  return entries;
};
var se_SingleMetricAnomalyDetector = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_AI] != null) {
    entries[_AI] = input[_AI];
  }
  if (input[_N] != null) {
    entries[_N] = input[_N];
  }
  if (input[_MN] != null) {
    entries[_MN] = input[_MN];
  }
  if (input[_D] != null) {
    const memberEntries = se_Dimensions(input[_D], context);
    if (((_a2 = input[_D]) == null ? void 0 : _a2.length) === 0) {
      entries.Dimensions = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Dimensions.${key}`;
      entries[loc] = value;
    });
  }
  if (input[_S] != null) {
    entries[_S] = input[_S];
  }
  return entries;
};
var se_StartMetricStreamsInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_Nam] != null) {
    const memberEntries = se_MetricStreamNames(input[_Nam], context);
    if (((_a2 = input[_Nam]) == null ? void 0 : _a2.length) === 0) {
      entries.Names = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Names.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_Statistics = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_StatisticSet = (input, context) => {
  const entries = {};
  if (input[_SCa] != null) {
    entries[_SCa] = serializeFloat(input[_SCa]);
  }
  if (input[_Su] != null) {
    entries[_Su] = serializeFloat(input[_Su]);
  }
  if (input[_Mi] != null) {
    entries[_Mi] = serializeFloat(input[_Mi]);
  }
  if (input[_Ma] != null) {
    entries[_Ma] = serializeFloat(input[_Ma]);
  }
  return entries;
};
var se_StopMetricStreamsInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_Nam] != null) {
    const memberEntries = se_MetricStreamNames(input[_Nam], context);
    if (((_a2 = input[_Nam]) == null ? void 0 : _a2.length) === 0) {
      entries.Names = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Names.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_Tag = (input, context) => {
  const entries = {};
  if (input[_K] != null) {
    entries[_K] = input[_K];
  }
  if (input[_Va] != null) {
    entries[_Va] = input[_Va];
  }
  return entries;
};
var se_TagKeyList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};
var se_TagList = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_Tag(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};
var se_TagResourceInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_RARN] != null) {
    entries[_RARN] = input[_RARN];
  }
  if (input[_Ta] != null) {
    const memberEntries = se_TagList(input[_Ta], context);
    if (((_a2 = input[_Ta]) == null ? void 0 : _a2.length) === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_UntagResourceInput = (input, context) => {
  var _a2;
  const entries = {};
  if (input[_RARN] != null) {
    entries[_RARN] = input[_RARN];
  }
  if (input[_TK] != null) {
    const memberEntries = se_TagKeyList(input[_TK], context);
    if (((_a2 = input[_TK]) == null ? void 0 : _a2.length) === 0) {
      entries.TagKeys = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagKeys.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};
var se_Values = (input, context) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = serializeFloat(entry);
    counter++;
  }
  return entries;
};
var de_AlarmHistoryItem = (output, context) => {
  const contents = {};
  if (output[_ANl] != null) {
    contents[_ANl] = expectString(output[_ANl]);
  }
  if (output[_ATl] != null) {
    contents[_ATl] = expectString(output[_ATl]);
  }
  if (output[_Ti] != null) {
    contents[_Ti] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Ti]));
  }
  if (output[_HIT] != null) {
    contents[_HIT] = expectString(output[_HIT]);
  }
  if (output[_HS] != null) {
    contents[_HS] = expectString(output[_HS]);
  }
  if (output[_HD] != null) {
    contents[_HD] = expectString(output[_HD]);
  }
  return contents;
};
var de_AlarmHistoryItems = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_AlarmHistoryItem(entry, context);
  });
};
var de_AnomalyDetector = (output, context) => {
  const contents = {};
  if (output[_N] != null) {
    contents[_N] = expectString(output[_N]);
  }
  if (output[_MN] != null) {
    contents[_MN] = expectString(output[_MN]);
  }
  if (output.Dimensions === "") {
    contents[_D] = [];
  } else if (output[_D] != null && output[_D][_m] != null) {
    contents[_D] = de_Dimensions(getArrayIfSingleItem(output[_D][_m]), context);
  }
  if (output[_S] != null) {
    contents[_S] = expectString(output[_S]);
  }
  if (output[_Co] != null) {
    contents[_Co] = de_AnomalyDetectorConfiguration(output[_Co], context);
  }
  if (output[_SV] != null) {
    contents[_SV] = expectString(output[_SV]);
  }
  if (output[_MC] != null) {
    contents[_MC] = de_MetricCharacteristics(output[_MC], context);
  }
  if (output[_SMAD] != null) {
    contents[_SMAD] = de_SingleMetricAnomalyDetector(output[_SMAD], context);
  }
  if (output[_MMAD] != null) {
    contents[_MMAD] = de_MetricMathAnomalyDetector(output[_MMAD], context);
  }
  return contents;
};
var de_AnomalyDetectorConfiguration = (output, context) => {
  const contents = {};
  if (output.ExcludedTimeRanges === "") {
    contents[_ETR] = [];
  } else if (output[_ETR] != null && output[_ETR][_m] != null) {
    contents[_ETR] = de_AnomalyDetectorExcludedTimeRanges(getArrayIfSingleItem(output[_ETR][_m]), context);
  }
  if (output[_MT] != null) {
    contents[_MT] = expectString(output[_MT]);
  }
  return contents;
};
var de_AnomalyDetectorExcludedTimeRanges = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Range(entry, context);
  });
};
var de_AnomalyDetectors = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_AnomalyDetector(entry, context);
  });
};
var de_BatchFailures = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_PartialFailure(entry, context);
  });
};
var de_CompositeAlarm = (output, context) => {
  const contents = {};
  if (output[_AE] != null) {
    contents[_AE] = parseBoolean(output[_AE]);
  }
  if (output.AlarmActions === "") {
    contents[_AA] = [];
  } else if (output[_AA] != null && output[_AA][_m] != null) {
    contents[_AA] = de_ResourceList(getArrayIfSingleItem(output[_AA][_m]), context);
  }
  if (output[_AAl] != null) {
    contents[_AAl] = expectString(output[_AAl]);
  }
  if (output[_ACUT] != null) {
    contents[_ACUT] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_ACUT]));
  }
  if (output[_AD] != null) {
    contents[_AD] = expectString(output[_AD]);
  }
  if (output[_ANl] != null) {
    contents[_ANl] = expectString(output[_ANl]);
  }
  if (output[_AR] != null) {
    contents[_AR] = expectString(output[_AR]);
  }
  if (output.InsufficientDataActions === "") {
    contents[_IDA] = [];
  } else if (output[_IDA] != null && output[_IDA][_m] != null) {
    contents[_IDA] = de_ResourceList(getArrayIfSingleItem(output[_IDA][_m]), context);
  }
  if (output.OKActions === "") {
    contents[_OKA] = [];
  } else if (output[_OKA] != null && output[_OKA][_m] != null) {
    contents[_OKA] = de_ResourceList(getArrayIfSingleItem(output[_OKA][_m]), context);
  }
  if (output[_SRt] != null) {
    contents[_SRt] = expectString(output[_SRt]);
  }
  if (output[_SRD] != null) {
    contents[_SRD] = expectString(output[_SRD]);
  }
  if (output[_SUT] != null) {
    contents[_SUT] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_SUT]));
  }
  if (output[_SV] != null) {
    contents[_SV] = expectString(output[_SV]);
  }
  if (output[_STT] != null) {
    contents[_STT] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_STT]));
  }
  if (output[_ASB] != null) {
    contents[_ASB] = expectString(output[_ASB]);
  }
  if (output[_ASR] != null) {
    contents[_ASR] = expectString(output[_ASR]);
  }
  if (output[_ASc] != null) {
    contents[_ASc] = expectString(output[_ASc]);
  }
  if (output[_ASWP] != null) {
    contents[_ASWP] = strictParseInt32(output[_ASWP]);
  }
  if (output[_ASEP] != null) {
    contents[_ASEP] = strictParseInt32(output[_ASEP]);
  }
  return contents;
};
var de_CompositeAlarms = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_CompositeAlarm(entry, context);
  });
};
var de_ConcurrentModificationException = (output, context) => {
  const contents = {};
  if (output[_Mes] != null) {
    contents[_Mes] = expectString(output[_Mes]);
  }
  return contents;
};
var de_DashboardEntries = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_DashboardEntry(entry, context);
  });
};
var de_DashboardEntry = (output, context) => {
  const contents = {};
  if (output[_DNa] != null) {
    contents[_DNa] = expectString(output[_DNa]);
  }
  if (output[_DAa] != null) {
    contents[_DAa] = expectString(output[_DAa]);
  }
  if (output[_LMa] != null) {
    contents[_LMa] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LMa]));
  }
  if (output[_Si] != null) {
    contents[_Si] = strictParseLong(output[_Si]);
  }
  return contents;
};
var de_DashboardInvalidInputError = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  if (output.dashboardValidationMessages === "") {
    contents[_dVM] = [];
  } else if (output[_dVM] != null && output[_dVM][_m] != null) {
    contents[_dVM] = de_DashboardValidationMessages(getArrayIfSingleItem(output[_dVM][_m]), context);
  }
  return contents;
};
var de_DashboardValidationMessage = (output, context) => {
  const contents = {};
  if (output[_DP] != null) {
    contents[_DP] = expectString(output[_DP]);
  }
  if (output[_Mes] != null) {
    contents[_Mes] = expectString(output[_Mes]);
  }
  return contents;
};
var de_DashboardValidationMessages = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_DashboardValidationMessage(entry, context);
  });
};
var de_Datapoint = (output, context) => {
  const contents = {};
  if (output[_Ti] != null) {
    contents[_Ti] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Ti]));
  }
  if (output[_SCa] != null) {
    contents[_SCa] = strictParseFloat(output[_SCa]);
  }
  if (output[_Av] != null) {
    contents[_Av] = strictParseFloat(output[_Av]);
  }
  if (output[_Su] != null) {
    contents[_Su] = strictParseFloat(output[_Su]);
  }
  if (output[_Mi] != null) {
    contents[_Mi] = strictParseFloat(output[_Mi]);
  }
  if (output[_Ma] != null) {
    contents[_Ma] = strictParseFloat(output[_Ma]);
  }
  if (output[_U] != null) {
    contents[_U] = expectString(output[_U]);
  }
  if (output.ExtendedStatistics === "") {
    contents[_ESx] = {};
  } else if (output[_ESx] != null && output[_ESx][_e] != null) {
    contents[_ESx] = de_DatapointValueMap(getArrayIfSingleItem(output[_ESx][_e]), context);
  }
  return contents;
};
var de_Datapoints = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Datapoint(entry, context);
  });
};
var de_DatapointValueMap = (output, context) => {
  return output.reduce((acc, pair) => {
    if (pair["value"] === null) {
      return acc;
    }
    acc[pair["key"]] = strictParseFloat(pair["value"]);
    return acc;
  }, {});
};
var de_DatapointValues = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return strictParseFloat(entry);
  });
};
var de_DeleteAnomalyDetectorOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_DeleteDashboardsOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_DeleteInsightRulesOutput = (output, context) => {
  const contents = {};
  if (output.Failures === "") {
    contents[_F] = [];
  } else if (output[_F] != null && output[_F][_m] != null) {
    contents[_F] = de_BatchFailures(getArrayIfSingleItem(output[_F][_m]), context);
  }
  return contents;
};
var de_DeleteMetricStreamOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_DescribeAlarmHistoryOutput = (output, context) => {
  const contents = {};
  if (output.AlarmHistoryItems === "") {
    contents[_AHI] = [];
  } else if (output[_AHI] != null && output[_AHI][_m] != null) {
    contents[_AHI] = de_AlarmHistoryItems(getArrayIfSingleItem(output[_AHI][_m]), context);
  }
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  return contents;
};
var de_DescribeAlarmsForMetricOutput = (output, context) => {
  const contents = {};
  if (output.MetricAlarms === "") {
    contents[_MA] = [];
  } else if (output[_MA] != null && output[_MA][_m] != null) {
    contents[_MA] = de_MetricAlarms(getArrayIfSingleItem(output[_MA][_m]), context);
  }
  return contents;
};
var de_DescribeAlarmsOutput = (output, context) => {
  const contents = {};
  if (output.CompositeAlarms === "") {
    contents[_CA] = [];
  } else if (output[_CA] != null && output[_CA][_m] != null) {
    contents[_CA] = de_CompositeAlarms(getArrayIfSingleItem(output[_CA][_m]), context);
  }
  if (output.MetricAlarms === "") {
    contents[_MA] = [];
  } else if (output[_MA] != null && output[_MA][_m] != null) {
    contents[_MA] = de_MetricAlarms(getArrayIfSingleItem(output[_MA][_m]), context);
  }
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  return contents;
};
var de_DescribeAnomalyDetectorsOutput = (output, context) => {
  const contents = {};
  if (output.AnomalyDetectors === "") {
    contents[_ADn] = [];
  } else if (output[_ADn] != null && output[_ADn][_m] != null) {
    contents[_ADn] = de_AnomalyDetectors(getArrayIfSingleItem(output[_ADn][_m]), context);
  }
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  return contents;
};
var de_DescribeInsightRulesOutput = (output, context) => {
  const contents = {};
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  if (output.InsightRules === "") {
    contents[_IR] = [];
  } else if (output[_IR] != null && output[_IR][_m] != null) {
    contents[_IR] = de_InsightRules(getArrayIfSingleItem(output[_IR][_m]), context);
  }
  return contents;
};
var de_Dimension = (output, context) => {
  const contents = {};
  if (output[_Na] != null) {
    contents[_Na] = expectString(output[_Na]);
  }
  if (output[_Va] != null) {
    contents[_Va] = expectString(output[_Va]);
  }
  return contents;
};
var de_Dimensions = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Dimension(entry, context);
  });
};
var de_DisableInsightRulesOutput = (output, context) => {
  const contents = {};
  if (output.Failures === "") {
    contents[_F] = [];
  } else if (output[_F] != null && output[_F][_m] != null) {
    contents[_F] = de_BatchFailures(getArrayIfSingleItem(output[_F][_m]), context);
  }
  return contents;
};
var de_EnableInsightRulesOutput = (output, context) => {
  const contents = {};
  if (output.Failures === "") {
    contents[_F] = [];
  } else if (output[_F] != null && output[_F][_m] != null) {
    contents[_F] = de_BatchFailures(getArrayIfSingleItem(output[_F][_m]), context);
  }
  return contents;
};
var de_GetDashboardOutput = (output, context) => {
  const contents = {};
  if (output[_DAa] != null) {
    contents[_DAa] = expectString(output[_DAa]);
  }
  if (output[_DB] != null) {
    contents[_DB] = expectString(output[_DB]);
  }
  if (output[_DNa] != null) {
    contents[_DNa] = expectString(output[_DNa]);
  }
  return contents;
};
var de_GetInsightRuleReportOutput = (output, context) => {
  const contents = {};
  if (output.KeyLabels === "") {
    contents[_KL] = [];
  } else if (output[_KL] != null && output[_KL][_m] != null) {
    contents[_KL] = de_InsightRuleContributorKeyLabels(getArrayIfSingleItem(output[_KL][_m]), context);
  }
  if (output[_ASg] != null) {
    contents[_ASg] = expectString(output[_ASg]);
  }
  if (output[_AV] != null) {
    contents[_AV] = strictParseFloat(output[_AV]);
  }
  if (output[_AUC] != null) {
    contents[_AUC] = strictParseLong(output[_AUC]);
  }
  if (output.Contributors === "") {
    contents[_Con] = [];
  } else if (output[_Con] != null && output[_Con][_m] != null) {
    contents[_Con] = de_InsightRuleContributors(getArrayIfSingleItem(output[_Con][_m]), context);
  }
  if (output.MetricDatapoints === "") {
    contents[_MDe] = [];
  } else if (output[_MDe] != null && output[_MDe][_m] != null) {
    contents[_MDe] = de_InsightRuleMetricDatapoints(getArrayIfSingleItem(output[_MDe][_m]), context);
  }
  return contents;
};
var de_GetMetricDataOutput = (output, context) => {
  const contents = {};
  if (output.MetricDataResults === "") {
    contents[_MDR] = [];
  } else if (output[_MDR] != null && output[_MDR][_m] != null) {
    contents[_MDR] = de_MetricDataResults(getArrayIfSingleItem(output[_MDR][_m]), context);
  }
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  if (output.Messages === "") {
    contents[_Mess] = [];
  } else if (output[_Mess] != null && output[_Mess][_m] != null) {
    contents[_Mess] = de_MetricDataResultMessages(getArrayIfSingleItem(output[_Mess][_m]), context);
  }
  return contents;
};
var de_GetMetricStatisticsOutput = (output, context) => {
  const contents = {};
  if (output[_L] != null) {
    contents[_L] = expectString(output[_L]);
  }
  if (output.Datapoints === "") {
    contents[_Da] = [];
  } else if (output[_Da] != null && output[_Da][_m] != null) {
    contents[_Da] = de_Datapoints(getArrayIfSingleItem(output[_Da][_m]), context);
  }
  return contents;
};
var de_GetMetricStreamOutput = (output, context) => {
  const contents = {};
  if (output[_Ar] != null) {
    contents[_Ar] = expectString(output[_Ar]);
  }
  if (output[_Na] != null) {
    contents[_Na] = expectString(output[_Na]);
  }
  if (output.IncludeFilters === "") {
    contents[_IF] = [];
  } else if (output[_IF] != null && output[_IF][_m] != null) {
    contents[_IF] = de_MetricStreamFilters(getArrayIfSingleItem(output[_IF][_m]), context);
  }
  if (output.ExcludeFilters === "") {
    contents[_EF] = [];
  } else if (output[_EF] != null && output[_EF][_m] != null) {
    contents[_EF] = de_MetricStreamFilters(getArrayIfSingleItem(output[_EF][_m]), context);
  }
  if (output[_FA] != null) {
    contents[_FA] = expectString(output[_FA]);
  }
  if (output[_RAo] != null) {
    contents[_RAo] = expectString(output[_RAo]);
  }
  if (output[_Stat] != null) {
    contents[_Stat] = expectString(output[_Stat]);
  }
  if (output[_CD] != null) {
    contents[_CD] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_CD]));
  }
  if (output[_LUD] != null) {
    contents[_LUD] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LUD]));
  }
  if (output[_OF] != null) {
    contents[_OF] = expectString(output[_OF]);
  }
  if (output.StatisticsConfigurations === "") {
    contents[_SC] = [];
  } else if (output[_SC] != null && output[_SC][_m] != null) {
    contents[_SC] = de_MetricStreamStatisticsConfigurations(getArrayIfSingleItem(output[_SC][_m]), context);
  }
  if (output[_ILAM] != null) {
    contents[_ILAM] = parseBoolean(output[_ILAM]);
  }
  return contents;
};
var de_GetMetricWidgetImageOutput = (output, context) => {
  const contents = {};
  if (output[_MWI] != null) {
    contents[_MWI] = context.base64Decoder(output[_MWI]);
  }
  return contents;
};
var de_InsightRule = (output, context) => {
  const contents = {};
  if (output[_Na] != null) {
    contents[_Na] = expectString(output[_Na]);
  }
  if (output[_Stat] != null) {
    contents[_Stat] = expectString(output[_Stat]);
  }
  if (output[_Sc] != null) {
    contents[_Sc] = expectString(output[_Sc]);
  }
  if (output[_De] != null) {
    contents[_De] = expectString(output[_De]);
  }
  if (output[_MRana] != null) {
    contents[_MRana] = parseBoolean(output[_MRana]);
  }
  return contents;
};
var de_InsightRuleContributor = (output, context) => {
  const contents = {};
  if (output.Keys === "") {
    contents[_Ke] = [];
  } else if (output[_Ke] != null && output[_Ke][_m] != null) {
    contents[_Ke] = de_InsightRuleContributorKeys(getArrayIfSingleItem(output[_Ke][_m]), context);
  }
  if (output[_AAV] != null) {
    contents[_AAV] = strictParseFloat(output[_AAV]);
  }
  if (output.Datapoints === "") {
    contents[_Da] = [];
  } else if (output[_Da] != null && output[_Da][_m] != null) {
    contents[_Da] = de_InsightRuleContributorDatapoints(getArrayIfSingleItem(output[_Da][_m]), context);
  }
  return contents;
};
var de_InsightRuleContributorDatapoint = (output, context) => {
  const contents = {};
  if (output[_Ti] != null) {
    contents[_Ti] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Ti]));
  }
  if (output[_AVp] != null) {
    contents[_AVp] = strictParseFloat(output[_AVp]);
  }
  return contents;
};
var de_InsightRuleContributorDatapoints = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_InsightRuleContributorDatapoint(entry, context);
  });
};
var de_InsightRuleContributorKeyLabels = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return expectString(entry);
  });
};
var de_InsightRuleContributorKeys = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return expectString(entry);
  });
};
var de_InsightRuleContributors = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_InsightRuleContributor(entry, context);
  });
};
var de_InsightRuleMetricDatapoint = (output, context) => {
  const contents = {};
  if (output[_Ti] != null) {
    contents[_Ti] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Ti]));
  }
  if (output[_UC] != null) {
    contents[_UC] = strictParseFloat(output[_UC]);
  }
  if (output[_MCV] != null) {
    contents[_MCV] = strictParseFloat(output[_MCV]);
  }
  if (output[_SCa] != null) {
    contents[_SCa] = strictParseFloat(output[_SCa]);
  }
  if (output[_Av] != null) {
    contents[_Av] = strictParseFloat(output[_Av]);
  }
  if (output[_Su] != null) {
    contents[_Su] = strictParseFloat(output[_Su]);
  }
  if (output[_Mi] != null) {
    contents[_Mi] = strictParseFloat(output[_Mi]);
  }
  if (output[_Ma] != null) {
    contents[_Ma] = strictParseFloat(output[_Ma]);
  }
  return contents;
};
var de_InsightRuleMetricDatapoints = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_InsightRuleMetricDatapoint(entry, context);
  });
};
var de_InsightRules = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_InsightRule(entry, context);
  });
};
var de_InternalServiceFault = (output, context) => {
  const contents = {};
  if (output[_Mes] != null) {
    contents[_Mes] = expectString(output[_Mes]);
  }
  return contents;
};
var de_InvalidFormatFault = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  return contents;
};
var de_InvalidNextToken = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  return contents;
};
var de_InvalidParameterCombinationException = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  return contents;
};
var de_InvalidParameterValueException = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  return contents;
};
var de_LimitExceededException = (output, context) => {
  const contents = {};
  if (output[_Mes] != null) {
    contents[_Mes] = expectString(output[_Mes]);
  }
  return contents;
};
var de_LimitExceededFault = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  return contents;
};
var de_ListDashboardsOutput = (output, context) => {
  const contents = {};
  if (output.DashboardEntries === "") {
    contents[_DE] = [];
  } else if (output[_DE] != null && output[_DE][_m] != null) {
    contents[_DE] = de_DashboardEntries(getArrayIfSingleItem(output[_DE][_m]), context);
  }
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  return contents;
};
var de_ListManagedInsightRulesOutput = (output, context) => {
  const contents = {};
  if (output.ManagedRules === "") {
    contents[_MRan] = [];
  } else if (output[_MRan] != null && output[_MRan][_m] != null) {
    contents[_MRan] = de_ManagedRuleDescriptions(getArrayIfSingleItem(output[_MRan][_m]), context);
  }
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  return contents;
};
var de_ListMetricsOutput = (output, context) => {
  const contents = {};
  if (output.Metrics === "") {
    contents[_M] = [];
  } else if (output[_M] != null && output[_M][_m] != null) {
    contents[_M] = de_Metrics(getArrayIfSingleItem(output[_M][_m]), context);
  }
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  if (output.OwningAccounts === "") {
    contents[_OAw] = [];
  } else if (output[_OAw] != null && output[_OAw][_m] != null) {
    contents[_OAw] = de_OwningAccounts(getArrayIfSingleItem(output[_OAw][_m]), context);
  }
  return contents;
};
var de_ListMetricStreamsOutput = (output, context) => {
  const contents = {};
  if (output[_NT] != null) {
    contents[_NT] = expectString(output[_NT]);
  }
  if (output.Entries === "") {
    contents[_En] = [];
  } else if (output[_En] != null && output[_En][_m] != null) {
    contents[_En] = de_MetricStreamEntries(getArrayIfSingleItem(output[_En][_m]), context);
  }
  return contents;
};
var de_ListTagsForResourceOutput = (output, context) => {
  const contents = {};
  if (output.Tags === "") {
    contents[_Ta] = [];
  } else if (output[_Ta] != null && output[_Ta][_m] != null) {
    contents[_Ta] = de_TagList(getArrayIfSingleItem(output[_Ta][_m]), context);
  }
  return contents;
};
var de_ManagedRuleDescription = (output, context) => {
  const contents = {};
  if (output[_TN] != null) {
    contents[_TN] = expectString(output[_TN]);
  }
  if (output[_RARN] != null) {
    contents[_RARN] = expectString(output[_RARN]);
  }
  if (output[_RS] != null) {
    contents[_RS] = de_ManagedRuleState(output[_RS], context);
  }
  return contents;
};
var de_ManagedRuleDescriptions = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_ManagedRuleDescription(entry, context);
  });
};
var de_ManagedRuleState = (output, context) => {
  const contents = {};
  if (output[_RNu] != null) {
    contents[_RNu] = expectString(output[_RNu]);
  }
  if (output[_Stat] != null) {
    contents[_Stat] = expectString(output[_Stat]);
  }
  return contents;
};
var de_MessageData = (output, context) => {
  const contents = {};
  if (output[_Cod] != null) {
    contents[_Cod] = expectString(output[_Cod]);
  }
  if (output[_Va] != null) {
    contents[_Va] = expectString(output[_Va]);
  }
  return contents;
};
var de_Metric = (output, context) => {
  const contents = {};
  if (output[_N] != null) {
    contents[_N] = expectString(output[_N]);
  }
  if (output[_MN] != null) {
    contents[_MN] = expectString(output[_MN]);
  }
  if (output.Dimensions === "") {
    contents[_D] = [];
  } else if (output[_D] != null && output[_D][_m] != null) {
    contents[_D] = de_Dimensions(getArrayIfSingleItem(output[_D][_m]), context);
  }
  return contents;
};
var de_MetricAlarm = (output, context) => {
  const contents = {};
  if (output[_ANl] != null) {
    contents[_ANl] = expectString(output[_ANl]);
  }
  if (output[_AAl] != null) {
    contents[_AAl] = expectString(output[_AAl]);
  }
  if (output[_AD] != null) {
    contents[_AD] = expectString(output[_AD]);
  }
  if (output[_ACUT] != null) {
    contents[_ACUT] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_ACUT]));
  }
  if (output[_AE] != null) {
    contents[_AE] = parseBoolean(output[_AE]);
  }
  if (output.OKActions === "") {
    contents[_OKA] = [];
  } else if (output[_OKA] != null && output[_OKA][_m] != null) {
    contents[_OKA] = de_ResourceList(getArrayIfSingleItem(output[_OKA][_m]), context);
  }
  if (output.AlarmActions === "") {
    contents[_AA] = [];
  } else if (output[_AA] != null && output[_AA][_m] != null) {
    contents[_AA] = de_ResourceList(getArrayIfSingleItem(output[_AA][_m]), context);
  }
  if (output.InsufficientDataActions === "") {
    contents[_IDA] = [];
  } else if (output[_IDA] != null && output[_IDA][_m] != null) {
    contents[_IDA] = de_ResourceList(getArrayIfSingleItem(output[_IDA][_m]), context);
  }
  if (output[_SV] != null) {
    contents[_SV] = expectString(output[_SV]);
  }
  if (output[_SRt] != null) {
    contents[_SRt] = expectString(output[_SRt]);
  }
  if (output[_SRD] != null) {
    contents[_SRD] = expectString(output[_SRD]);
  }
  if (output[_SUT] != null) {
    contents[_SUT] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_SUT]));
  }
  if (output[_MN] != null) {
    contents[_MN] = expectString(output[_MN]);
  }
  if (output[_N] != null) {
    contents[_N] = expectString(output[_N]);
  }
  if (output[_St] != null) {
    contents[_St] = expectString(output[_St]);
  }
  if (output[_ES] != null) {
    contents[_ES] = expectString(output[_ES]);
  }
  if (output.Dimensions === "") {
    contents[_D] = [];
  } else if (output[_D] != null && output[_D][_m] != null) {
    contents[_D] = de_Dimensions(getArrayIfSingleItem(output[_D][_m]), context);
  }
  if (output[_P] != null) {
    contents[_P] = strictParseInt32(output[_P]);
  }
  if (output[_U] != null) {
    contents[_U] = expectString(output[_U]);
  }
  if (output[_EP] != null) {
    contents[_EP] = strictParseInt32(output[_EP]);
  }
  if (output[_DTA] != null) {
    contents[_DTA] = strictParseInt32(output[_DTA]);
  }
  if (output[_Th] != null) {
    contents[_Th] = strictParseFloat(output[_Th]);
  }
  if (output[_CO] != null) {
    contents[_CO] = expectString(output[_CO]);
  }
  if (output[_TMD] != null) {
    contents[_TMD] = expectString(output[_TMD]);
  }
  if (output[_ELSCP] != null) {
    contents[_ELSCP] = expectString(output[_ELSCP]);
  }
  if (output.Metrics === "") {
    contents[_M] = [];
  } else if (output[_M] != null && output[_M][_m] != null) {
    contents[_M] = de_MetricDataQueries(getArrayIfSingleItem(output[_M][_m]), context);
  }
  if (output[_TMI] != null) {
    contents[_TMI] = expectString(output[_TMI]);
  }
  if (output[_ESv] != null) {
    contents[_ESv] = expectString(output[_ESv]);
  }
  if (output[_STT] != null) {
    contents[_STT] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_STT]));
  }
  return contents;
};
var de_MetricAlarms = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MetricAlarm(entry, context);
  });
};
var de_MetricCharacteristics = (output, context) => {
  const contents = {};
  if (output[_PS] != null) {
    contents[_PS] = parseBoolean(output[_PS]);
  }
  return contents;
};
var de_MetricDataQueries = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MetricDataQuery(entry, context);
  });
};
var de_MetricDataQuery = (output, context) => {
  const contents = {};
  if (output[_I] != null) {
    contents[_I] = expectString(output[_I]);
  }
  if (output[_MS] != null) {
    contents[_MS] = de_MetricStat(output[_MS], context);
  }
  if (output[_Ex] != null) {
    contents[_Ex] = expectString(output[_Ex]);
  }
  if (output[_L] != null) {
    contents[_L] = expectString(output[_L]);
  }
  if (output[_RD] != null) {
    contents[_RD] = parseBoolean(output[_RD]);
  }
  if (output[_P] != null) {
    contents[_P] = strictParseInt32(output[_P]);
  }
  if (output[_AI] != null) {
    contents[_AI] = expectString(output[_AI]);
  }
  return contents;
};
var de_MetricDataResult = (output, context) => {
  const contents = {};
  if (output[_I] != null) {
    contents[_I] = expectString(output[_I]);
  }
  if (output[_L] != null) {
    contents[_L] = expectString(output[_L]);
  }
  if (output.Timestamps === "") {
    contents[_Tim] = [];
  } else if (output[_Tim] != null && output[_Tim][_m] != null) {
    contents[_Tim] = de_Timestamps(getArrayIfSingleItem(output[_Tim][_m]), context);
  }
  if (output.Values === "") {
    contents[_Val] = [];
  } else if (output[_Val] != null && output[_Val][_m] != null) {
    contents[_Val] = de_DatapointValues(getArrayIfSingleItem(output[_Val][_m]), context);
  }
  if (output[_SCt] != null) {
    contents[_SCt] = expectString(output[_SCt]);
  }
  if (output.Messages === "") {
    contents[_Mess] = [];
  } else if (output[_Mess] != null && output[_Mess][_m] != null) {
    contents[_Mess] = de_MetricDataResultMessages(getArrayIfSingleItem(output[_Mess][_m]), context);
  }
  return contents;
};
var de_MetricDataResultMessages = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MessageData(entry, context);
  });
};
var de_MetricDataResults = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MetricDataResult(entry, context);
  });
};
var de_MetricMathAnomalyDetector = (output, context) => {
  const contents = {};
  if (output.MetricDataQueries === "") {
    contents[_MDQ] = [];
  } else if (output[_MDQ] != null && output[_MDQ][_m] != null) {
    contents[_MDQ] = de_MetricDataQueries(getArrayIfSingleItem(output[_MDQ][_m]), context);
  }
  return contents;
};
var de_Metrics = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Metric(entry, context);
  });
};
var de_MetricStat = (output, context) => {
  const contents = {};
  if (output[_Me] != null) {
    contents[_Me] = de_Metric(output[_Me], context);
  }
  if (output[_P] != null) {
    contents[_P] = strictParseInt32(output[_P]);
  }
  if (output[_S] != null) {
    contents[_S] = expectString(output[_S]);
  }
  if (output[_U] != null) {
    contents[_U] = expectString(output[_U]);
  }
  return contents;
};
var de_MetricStreamEntries = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MetricStreamEntry(entry, context);
  });
};
var de_MetricStreamEntry = (output, context) => {
  const contents = {};
  if (output[_Ar] != null) {
    contents[_Ar] = expectString(output[_Ar]);
  }
  if (output[_CD] != null) {
    contents[_CD] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_CD]));
  }
  if (output[_LUD] != null) {
    contents[_LUD] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_LUD]));
  }
  if (output[_Na] != null) {
    contents[_Na] = expectString(output[_Na]);
  }
  if (output[_FA] != null) {
    contents[_FA] = expectString(output[_FA]);
  }
  if (output[_Stat] != null) {
    contents[_Stat] = expectString(output[_Stat]);
  }
  if (output[_OF] != null) {
    contents[_OF] = expectString(output[_OF]);
  }
  return contents;
};
var de_MetricStreamFilter = (output, context) => {
  const contents = {};
  if (output[_N] != null) {
    contents[_N] = expectString(output[_N]);
  }
  if (output.MetricNames === "") {
    contents[_MNe] = [];
  } else if (output[_MNe] != null && output[_MNe][_m] != null) {
    contents[_MNe] = de_MetricStreamFilterMetricNames(getArrayIfSingleItem(output[_MNe][_m]), context);
  }
  return contents;
};
var de_MetricStreamFilterMetricNames = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return expectString(entry);
  });
};
var de_MetricStreamFilters = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MetricStreamFilter(entry, context);
  });
};
var de_MetricStreamStatisticsAdditionalStatistics = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return expectString(entry);
  });
};
var de_MetricStreamStatisticsConfiguration = (output, context) => {
  const contents = {};
  if (output.IncludeMetrics === "") {
    contents[_IM] = [];
  } else if (output[_IM] != null && output[_IM][_m] != null) {
    contents[_IM] = de_MetricStreamStatisticsIncludeMetrics(getArrayIfSingleItem(output[_IM][_m]), context);
  }
  if (output.AdditionalStatistics === "") {
    contents[_AS] = [];
  } else if (output[_AS] != null && output[_AS][_m] != null) {
    contents[_AS] = de_MetricStreamStatisticsAdditionalStatistics(getArrayIfSingleItem(output[_AS][_m]), context);
  }
  return contents;
};
var de_MetricStreamStatisticsConfigurations = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MetricStreamStatisticsConfiguration(entry, context);
  });
};
var de_MetricStreamStatisticsIncludeMetrics = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_MetricStreamStatisticsMetric(entry, context);
  });
};
var de_MetricStreamStatisticsMetric = (output, context) => {
  const contents = {};
  if (output[_N] != null) {
    contents[_N] = expectString(output[_N]);
  }
  if (output[_MN] != null) {
    contents[_MN] = expectString(output[_MN]);
  }
  return contents;
};
var de_MissingRequiredParameterException = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  return contents;
};
var de_OwningAccounts = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return expectString(entry);
  });
};
var de_PartialFailure = (output, context) => {
  const contents = {};
  if (output[_FR] != null) {
    contents[_FR] = expectString(output[_FR]);
  }
  if (output[_ETx] != null) {
    contents[_ETx] = expectString(output[_ETx]);
  }
  if (output[_FC] != null) {
    contents[_FC] = expectString(output[_FC]);
  }
  if (output[_FD] != null) {
    contents[_FD] = expectString(output[_FD]);
  }
  return contents;
};
var de_PutAnomalyDetectorOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_PutDashboardOutput = (output, context) => {
  const contents = {};
  if (output.DashboardValidationMessages === "") {
    contents[_DVM] = [];
  } else if (output[_DVM] != null && output[_DVM][_m] != null) {
    contents[_DVM] = de_DashboardValidationMessages(getArrayIfSingleItem(output[_DVM][_m]), context);
  }
  return contents;
};
var de_PutInsightRuleOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_PutManagedInsightRulesOutput = (output, context) => {
  const contents = {};
  if (output.Failures === "") {
    contents[_F] = [];
  } else if (output[_F] != null && output[_F][_m] != null) {
    contents[_F] = de_BatchFailures(getArrayIfSingleItem(output[_F][_m]), context);
  }
  return contents;
};
var de_PutMetricStreamOutput = (output, context) => {
  const contents = {};
  if (output[_Ar] != null) {
    contents[_Ar] = expectString(output[_Ar]);
  }
  return contents;
};
var de_Range = (output, context) => {
  const contents = {};
  if (output[_ST] != null) {
    contents[_ST] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_ST]));
  }
  if (output[_ET] != null) {
    contents[_ET] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_ET]));
  }
  return contents;
};
var de_ResourceList = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return expectString(entry);
  });
};
var de_ResourceNotFound = (output, context) => {
  const contents = {};
  if (output[_me] != null) {
    contents[_me] = expectString(output[_me]);
  }
  return contents;
};
var de_ResourceNotFoundException = (output, context) => {
  const contents = {};
  if (output[_RT] != null) {
    contents[_RT] = expectString(output[_RT]);
  }
  if (output[_RI] != null) {
    contents[_RI] = expectString(output[_RI]);
  }
  if (output[_Mes] != null) {
    contents[_Mes] = expectString(output[_Mes]);
  }
  return contents;
};
var de_SingleMetricAnomalyDetector = (output, context) => {
  const contents = {};
  if (output[_AI] != null) {
    contents[_AI] = expectString(output[_AI]);
  }
  if (output[_N] != null) {
    contents[_N] = expectString(output[_N]);
  }
  if (output[_MN] != null) {
    contents[_MN] = expectString(output[_MN]);
  }
  if (output.Dimensions === "") {
    contents[_D] = [];
  } else if (output[_D] != null && output[_D][_m] != null) {
    contents[_D] = de_Dimensions(getArrayIfSingleItem(output[_D][_m]), context);
  }
  if (output[_S] != null) {
    contents[_S] = expectString(output[_S]);
  }
  return contents;
};
var de_StartMetricStreamsOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_StopMetricStreamsOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_Tag = (output, context) => {
  const contents = {};
  if (output[_K] != null) {
    contents[_K] = expectString(output[_K]);
  }
  if (output[_Va] != null) {
    contents[_Va] = expectString(output[_Va]);
  }
  return contents;
};
var de_TagList = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return de_Tag(entry, context);
  });
};
var de_TagResourceOutput = (output, context) => {
  const contents = {};
  return contents;
};
var de_Timestamps = (output, context) => {
  return (output || []).filter((e2) => e2 != null).map((entry) => {
    return expectNonNull(parseRfc3339DateTimeWithOffset(entry));
  });
};
var de_UntagResourceOutput = (output, context) => {
  const contents = {};
  return contents;
};
var deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var throwDefaultError = withBaseException(CloudWatchServiceException);
var buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
};
var SHARED_HEADERS = {
  "content-type": "application/x-www-form-urlencoded"
};
var _ = "2010-08-01";
var _A = "Action";
var _AA = "AlarmActions";
var _AAV = "ApproximateAggregateValue";
var _AAl = "AlarmArn";
var _ACUT = "AlarmConfigurationUpdatedTimestamp";
var _AD = "AlarmDescription";
var _ADT = "AnomalyDetectorTypes";
var _ADn = "AnomalyDetectors";
var _AE = "ActionsEnabled";
var _AHI = "AlarmHistoryItems";
var _AI = "AccountId";
var _AN = "AlarmNames";
var _ANP = "AlarmNamePrefix";
var _ANl = "AlarmName";
var _AP = "ActionPrefix";
var _AR = "AlarmRule";
var _AS = "AdditionalStatistics";
var _ASB = "ActionsSuppressedBy";
var _ASEP = "ActionsSuppressorExtensionPeriod";
var _ASR = "ActionsSuppressedReason";
var _ASWP = "ActionsSuppressorWaitPeriod";
var _ASc = "ActionsSuppressor";
var _ASg = "AggregationStatistic";
var _AT = "AlarmTypes";
var _ATl = "AlarmType";
var _AUC = "ApproximateUniqueCount";
var _AV = "AggregateValue";
var _AVp = "ApproximateValue";
var _Ar = "Arn";
var _At = "Attributes";
var _Av = "Average";
var _C = "Counts";
var _CA = "CompositeAlarms";
var _CD = "CreationDate";
var _CO = "ComparisonOperator";
var _COAN = "ChildrenOfAlarmName";
var _Co = "Configuration";
var _Cod = "Code";
var _Con = "Contributors";
var _D = "Dimensions";
var _DA = "DeleteAlarms";
var _DAA = "DisableAlarmActions";
var _DAD = "DeleteAnomalyDetector";
var _DADe = "DescribeAnomalyDetectors";
var _DAFM = "DescribeAlarmsForMetric";
var _DAH = "DescribeAlarmHistory";
var _DAa = "DashboardArn";
var _DAe = "DescribeAlarms";
var _DB = "DashboardBody";
var _DD = "DeleteDashboards";
var _DE = "DashboardEntries";
var _DIR = "DeleteInsightRules";
var _DIRe = "DescribeInsightRules";
var _DIRi = "DisableInsightRules";
var _DMS = "DeleteMetricStream";
var _DN = "DashboardNames";
var _DNP = "DashboardNamePrefix";
var _DNa = "DashboardName";
var _DP = "DataPath";
var _DTA = "DatapointsToAlarm";
var _DVM = "DashboardValidationMessages";
var _Da = "Datapoints";
var _De = "Definition";
var _E = "Entity";
var _EAA = "EnableAlarmActions";
var _ED = "EndDate";
var _EF = "ExcludeFilters";
var _EIR = "EnableInsightRules";
var _ELSCP = "EvaluateLowSampleCountPercentile";
var _EMD = "EntityMetricData";
var _EP = "EvaluationPeriods";
var _ES = "ExtendedStatistic";
var _ESv = "EvaluationState";
var _ESx = "ExtendedStatistics";
var _ET = "EndTime";
var _ETR = "ExcludedTimeRanges";
var _ETx = "ExceptionType";
var _En = "Entries";
var _Ex = "Expression";
var _F = "Failures";
var _FA = "FirehoseArn";
var _FC = "FailureCode";
var _FD = "FailureDescription";
var _FR = "FailureResource";
var _GD = "GetDashboard";
var _GIRR = "GetInsightRuleReport";
var _GMD = "GetMetricData";
var _GMS = "GetMetricStatistics";
var _GMSe = "GetMetricStream";
var _GMWI = "GetMetricWidgetImage";
var _HD = "HistoryData";
var _HIT = "HistoryItemType";
var _HS = "HistorySummary";
var _I = "Id";
var _IDA = "InsufficientDataActions";
var _IF = "IncludeFilters";
var _ILA = "IncludeLinkedAccounts";
var _ILAM = "IncludeLinkedAccountsMetrics";
var _IM = "IncludeMetrics";
var _IR = "InsightRules";
var _K = "Key";
var _KA = "KeyAttributes";
var _KL = "KeyLabels";
var _Ke = "Keys";
var _L = "Label";
var _LD = "ListDashboards";
var _LM = "ListMetrics";
var _LMIR = "ListManagedInsightRules";
var _LMS = "ListMetricStreams";
var _LMa = "LastModified";
var _LO = "LabelOptions";
var _LTFR = "ListTagsForResource";
var _LUD = "LastUpdateDate";
var _M = "Metrics";
var _MA = "MetricAlarms";
var _MC = "MetricCharacteristics";
var _MCC = "MaxContributorCount";
var _MCV = "MaxContributorValue";
var _MD = "MetricData";
var _MDQ = "MetricDataQueries";
var _MDR = "MetricDataResults";
var _MDa = "MaxDatapoints";
var _MDe = "MetricDatapoints";
var _MMAD = "MetricMathAnomalyDetector";
var _MN = "MetricName";
var _MNe = "MetricNames";
var _MR = "MaxRecords";
var _MRa = "MaxResults";
var _MRan = "ManagedRules";
var _MRana = "ManagedRule";
var _MS = "MetricStat";
var _MT = "MetricTimezone";
var _MW = "MetricWidget";
var _MWI = "MetricWidgetImage";
var _Ma = "Maximum";
var _Me = "Metric";
var _Mes = "Message";
var _Mess = "Messages";
var _Mi = "Minimum";
var _N = "Namespace";
var _NT = "NextToken";
var _Na = "Name";
var _Nam = "Names";
var _OA = "OwningAccount";
var _OAw = "OwningAccounts";
var _OB = "OrderBy";
var _OF = "OutputFormat";
var _OKA = "OKActions";
var _P = "Period";
var _PAD = "PutAnomalyDetector";
var _PCA = "PutCompositeAlarm";
var _PD = "PutDashboard";
var _PIR = "PutInsightRule";
var _PMA = "PutMetricAlarm";
var _PMD = "PutMetricData";
var _PMIR = "PutManagedInsightRules";
var _PMS = "PutMetricStream";
var _POAN = "ParentsOfAlarmName";
var _PS = "PeriodicSpikes";
var _RA = "RecentlyActive";
var _RARN = "ResourceARN";
var _RAo = "RoleArn";
var _RD = "ReturnData";
var _RDu = "RuleDefinition";
var _RI = "ResourceId";
var _RN = "RuleNames";
var _RNu = "RuleName";
var _RS = "RuleState";
var _RT = "ResourceType";
var _S = "Stat";
var _SAS = "SetAlarmState";
var _SB = "ScanBy";
var _SC = "StatisticsConfigurations";
var _SCa = "SampleCount";
var _SCt = "StatusCode";
var _SD = "StartDate";
var _SEV = "StrictEntityValidation";
var _SMAD = "SingleMetricAnomalyDetector";
var _SMS = "StartMetricStreams";
var _SMSt = "StopMetricStreams";
var _SR = "StorageResolution";
var _SRD = "StateReasonData";
var _SRt = "StateReason";
var _ST = "StartTime";
var _STT = "StateTransitionedTimestamp";
var _SUT = "StateUpdatedTimestamp";
var _SV = "StateValue";
var _SVt = "StatisticValues";
var _Sc = "Schema";
var _Si = "Size";
var _St = "Statistic";
var _Sta = "Statistics";
var _Stat = "State";
var _Su = "Sum";
var _T = "Timezone";
var _TK = "TagKeys";
var _TMD = "TreatMissingData";
var _TMI = "ThresholdMetricId";
var _TN = "TemplateName";
var _TR = "TagResource";
var _Ta = "Tags";
var _Th = "Threshold";
var _Ti = "Timestamp";
var _Tim = "Timestamps";
var _U = "Unit";
var _UC = "UniqueContributors";
var _UR = "UntagResource";
var _V = "Version";
var _Va = "Value";
var _Val = "Values";
var _dVM = "dashboardValidationMessages";
var _e = "entry";
var _m = "member";
var _me = "message";
var buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&");
var loadQueryErrorCode = (output, data) => {
  var _a2;
  if (((_a2 = data.Error) == null ? void 0 : _a2.Code) !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DeleteAlarmsCommand.js
var DeleteAlarmsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DeleteAlarms", {}).n("CloudWatchClient", "DeleteAlarmsCommand").f(void 0, void 0).ser(se_DeleteAlarmsCommand).de(de_DeleteAlarmsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DeleteAnomalyDetectorCommand.js
var DeleteAnomalyDetectorCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DeleteAnomalyDetector", {}).n("CloudWatchClient", "DeleteAnomalyDetectorCommand").f(void 0, void 0).ser(se_DeleteAnomalyDetectorCommand).de(de_DeleteAnomalyDetectorCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DeleteDashboardsCommand.js
var DeleteDashboardsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DeleteDashboards", {}).n("CloudWatchClient", "DeleteDashboardsCommand").f(void 0, void 0).ser(se_DeleteDashboardsCommand).de(de_DeleteDashboardsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DeleteInsightRulesCommand.js
var DeleteInsightRulesCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DeleteInsightRules", {}).n("CloudWatchClient", "DeleteInsightRulesCommand").f(void 0, void 0).ser(se_DeleteInsightRulesCommand).de(de_DeleteInsightRulesCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DeleteMetricStreamCommand.js
var DeleteMetricStreamCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DeleteMetricStream", {}).n("CloudWatchClient", "DeleteMetricStreamCommand").f(void 0, void 0).ser(se_DeleteMetricStreamCommand).de(de_DeleteMetricStreamCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DescribeAlarmHistoryCommand.js
var DescribeAlarmHistoryCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DescribeAlarmHistory", {}).n("CloudWatchClient", "DescribeAlarmHistoryCommand").f(void 0, void 0).ser(se_DescribeAlarmHistoryCommand).de(de_DescribeAlarmHistoryCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DescribeAlarmsCommand.js
var DescribeAlarmsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DescribeAlarms", {}).n("CloudWatchClient", "DescribeAlarmsCommand").f(void 0, void 0).ser(se_DescribeAlarmsCommand).de(de_DescribeAlarmsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DescribeAlarmsForMetricCommand.js
var DescribeAlarmsForMetricCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DescribeAlarmsForMetric", {}).n("CloudWatchClient", "DescribeAlarmsForMetricCommand").f(void 0, void 0).ser(se_DescribeAlarmsForMetricCommand).de(de_DescribeAlarmsForMetricCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DescribeAnomalyDetectorsCommand.js
var DescribeAnomalyDetectorsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DescribeAnomalyDetectors", {}).n("CloudWatchClient", "DescribeAnomalyDetectorsCommand").f(void 0, void 0).ser(se_DescribeAnomalyDetectorsCommand).de(de_DescribeAnomalyDetectorsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DescribeInsightRulesCommand.js
var DescribeInsightRulesCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DescribeInsightRules", {}).n("CloudWatchClient", "DescribeInsightRulesCommand").f(void 0, void 0).ser(se_DescribeInsightRulesCommand).de(de_DescribeInsightRulesCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DisableAlarmActionsCommand.js
var DisableAlarmActionsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DisableAlarmActions", {}).n("CloudWatchClient", "DisableAlarmActionsCommand").f(void 0, void 0).ser(se_DisableAlarmActionsCommand).de(de_DisableAlarmActionsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/DisableInsightRulesCommand.js
var DisableInsightRulesCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "DisableInsightRules", {}).n("CloudWatchClient", "DisableInsightRulesCommand").f(void 0, void 0).ser(se_DisableInsightRulesCommand).de(de_DisableInsightRulesCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/EnableAlarmActionsCommand.js
var EnableAlarmActionsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "EnableAlarmActions", {}).n("CloudWatchClient", "EnableAlarmActionsCommand").f(void 0, void 0).ser(se_EnableAlarmActionsCommand).de(de_EnableAlarmActionsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/EnableInsightRulesCommand.js
var EnableInsightRulesCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "EnableInsightRules", {}).n("CloudWatchClient", "EnableInsightRulesCommand").f(void 0, void 0).ser(se_EnableInsightRulesCommand).de(de_EnableInsightRulesCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/GetDashboardCommand.js
var GetDashboardCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "GetDashboard", {}).n("CloudWatchClient", "GetDashboardCommand").f(void 0, void 0).ser(se_GetDashboardCommand).de(de_GetDashboardCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/GetInsightRuleReportCommand.js
var GetInsightRuleReportCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "GetInsightRuleReport", {}).n("CloudWatchClient", "GetInsightRuleReportCommand").f(void 0, void 0).ser(se_GetInsightRuleReportCommand).de(de_GetInsightRuleReportCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/GetMetricDataCommand.js
var GetMetricDataCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "GetMetricData", {}).n("CloudWatchClient", "GetMetricDataCommand").f(void 0, void 0).ser(se_GetMetricDataCommand).de(de_GetMetricDataCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/GetMetricStatisticsCommand.js
var GetMetricStatisticsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "GetMetricStatistics", {}).n("CloudWatchClient", "GetMetricStatisticsCommand").f(void 0, void 0).ser(se_GetMetricStatisticsCommand).de(de_GetMetricStatisticsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/GetMetricStreamCommand.js
var GetMetricStreamCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "GetMetricStream", {}).n("CloudWatchClient", "GetMetricStreamCommand").f(void 0, void 0).ser(se_GetMetricStreamCommand).de(de_GetMetricStreamCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/GetMetricWidgetImageCommand.js
var GetMetricWidgetImageCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "GetMetricWidgetImage", {}).n("CloudWatchClient", "GetMetricWidgetImageCommand").f(void 0, void 0).ser(se_GetMetricWidgetImageCommand).de(de_GetMetricWidgetImageCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/ListDashboardsCommand.js
var ListDashboardsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "ListDashboards", {}).n("CloudWatchClient", "ListDashboardsCommand").f(void 0, void 0).ser(se_ListDashboardsCommand).de(de_ListDashboardsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/ListManagedInsightRulesCommand.js
var ListManagedInsightRulesCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "ListManagedInsightRules", {}).n("CloudWatchClient", "ListManagedInsightRulesCommand").f(void 0, void 0).ser(se_ListManagedInsightRulesCommand).de(de_ListManagedInsightRulesCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/ListMetricsCommand.js
var ListMetricsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "ListMetrics", {}).n("CloudWatchClient", "ListMetricsCommand").f(void 0, void 0).ser(se_ListMetricsCommand).de(de_ListMetricsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/ListMetricStreamsCommand.js
var ListMetricStreamsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "ListMetricStreams", {}).n("CloudWatchClient", "ListMetricStreamsCommand").f(void 0, void 0).ser(se_ListMetricStreamsCommand).de(de_ListMetricStreamsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/ListTagsForResourceCommand.js
var ListTagsForResourceCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "ListTagsForResource", {}).n("CloudWatchClient", "ListTagsForResourceCommand").f(void 0, void 0).ser(se_ListTagsForResourceCommand).de(de_ListTagsForResourceCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutAnomalyDetectorCommand.js
var PutAnomalyDetectorCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "PutAnomalyDetector", {}).n("CloudWatchClient", "PutAnomalyDetectorCommand").f(void 0, void 0).ser(se_PutAnomalyDetectorCommand).de(de_PutAnomalyDetectorCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutCompositeAlarmCommand.js
var PutCompositeAlarmCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "PutCompositeAlarm", {}).n("CloudWatchClient", "PutCompositeAlarmCommand").f(void 0, void 0).ser(se_PutCompositeAlarmCommand).de(de_PutCompositeAlarmCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutDashboardCommand.js
var PutDashboardCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "PutDashboard", {}).n("CloudWatchClient", "PutDashboardCommand").f(void 0, void 0).ser(se_PutDashboardCommand).de(de_PutDashboardCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutInsightRuleCommand.js
var PutInsightRuleCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "PutInsightRule", {}).n("CloudWatchClient", "PutInsightRuleCommand").f(void 0, void 0).ser(se_PutInsightRuleCommand).de(de_PutInsightRuleCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutManagedInsightRulesCommand.js
var PutManagedInsightRulesCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "PutManagedInsightRules", {}).n("CloudWatchClient", "PutManagedInsightRulesCommand").f(void 0, void 0).ser(se_PutManagedInsightRulesCommand).de(de_PutManagedInsightRulesCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutMetricAlarmCommand.js
var PutMetricAlarmCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "PutMetricAlarm", {}).n("CloudWatchClient", "PutMetricAlarmCommand").f(void 0, void 0).ser(se_PutMetricAlarmCommand).de(de_PutMetricAlarmCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutMetricDataCommand.js
var PutMetricDataCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions()),
    getCompressionPlugin(config, {
      encodings: ["gzip"]
    })
  ];
}).s("GraniteServiceVersion20100801", "PutMetricData", {}).n("CloudWatchClient", "PutMetricDataCommand").f(void 0, void 0).ser(se_PutMetricDataCommand).de(de_PutMetricDataCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutMetricStreamCommand.js
var PutMetricStreamCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "PutMetricStream", {}).n("CloudWatchClient", "PutMetricStreamCommand").f(void 0, void 0).ser(se_PutMetricStreamCommand).de(de_PutMetricStreamCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/SetAlarmStateCommand.js
var SetAlarmStateCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "SetAlarmState", {}).n("CloudWatchClient", "SetAlarmStateCommand").f(void 0, void 0).ser(se_SetAlarmStateCommand).de(de_SetAlarmStateCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/StartMetricStreamsCommand.js
var StartMetricStreamsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "StartMetricStreams", {}).n("CloudWatchClient", "StartMetricStreamsCommand").f(void 0, void 0).ser(se_StartMetricStreamsCommand).de(de_StartMetricStreamsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/StopMetricStreamsCommand.js
var StopMetricStreamsCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "StopMetricStreams", {}).n("CloudWatchClient", "StopMetricStreamsCommand").f(void 0, void 0).ser(se_StopMetricStreamsCommand).de(de_StopMetricStreamsCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/TagResourceCommand.js
var TagResourceCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "TagResource", {}).n("CloudWatchClient", "TagResourceCommand").f(void 0, void 0).ser(se_TagResourceCommand).de(de_TagResourceCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/UntagResourceCommand.js
var UntagResourceCommand = class extends Command.classBuilder().ep(commonParams).m(function(Command2, cs, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("GraniteServiceVersion20100801", "UntagResource", {}).n("CloudWatchClient", "UntagResourceCommand").f(void 0, void 0).ser(se_UntagResourceCommand).de(de_UntagResourceCommand).build() {
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/CloudWatch.js
var commands = {
  DeleteAlarmsCommand,
  DeleteAnomalyDetectorCommand,
  DeleteDashboardsCommand,
  DeleteInsightRulesCommand,
  DeleteMetricStreamCommand,
  DescribeAlarmHistoryCommand,
  DescribeAlarmsCommand,
  DescribeAlarmsForMetricCommand,
  DescribeAnomalyDetectorsCommand,
  DescribeInsightRulesCommand,
  DisableAlarmActionsCommand,
  DisableInsightRulesCommand,
  EnableAlarmActionsCommand,
  EnableInsightRulesCommand,
  GetDashboardCommand,
  GetInsightRuleReportCommand,
  GetMetricDataCommand,
  GetMetricStatisticsCommand,
  GetMetricStreamCommand,
  GetMetricWidgetImageCommand,
  ListDashboardsCommand,
  ListManagedInsightRulesCommand,
  ListMetricsCommand,
  ListMetricStreamsCommand,
  ListTagsForResourceCommand,
  PutAnomalyDetectorCommand,
  PutCompositeAlarmCommand,
  PutDashboardCommand,
  PutInsightRuleCommand,
  PutManagedInsightRulesCommand,
  PutMetricAlarmCommand,
  PutMetricDataCommand,
  PutMetricStreamCommand,
  SetAlarmStateCommand,
  StartMetricStreamsCommand,
  StopMetricStreamsCommand,
  TagResourceCommand,
  UntagResourceCommand
};
var CloudWatch = class extends CloudWatchClient {
};
createAggregatedClient(commands, CloudWatch);

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/DescribeAlarmHistoryPaginator.js
var paginateDescribeAlarmHistory = createPaginator(CloudWatchClient, DescribeAlarmHistoryCommand, "NextToken", "NextToken", "MaxRecords");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/DescribeAlarmsPaginator.js
var paginateDescribeAlarms = createPaginator(CloudWatchClient, DescribeAlarmsCommand, "NextToken", "NextToken", "MaxRecords");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/DescribeAnomalyDetectorsPaginator.js
var paginateDescribeAnomalyDetectors = createPaginator(CloudWatchClient, DescribeAnomalyDetectorsCommand, "NextToken", "NextToken", "MaxResults");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/DescribeInsightRulesPaginator.js
var paginateDescribeInsightRules = createPaginator(CloudWatchClient, DescribeInsightRulesCommand, "NextToken", "NextToken", "MaxResults");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/GetMetricDataPaginator.js
var paginateGetMetricData = createPaginator(CloudWatchClient, GetMetricDataCommand, "NextToken", "NextToken", "MaxDatapoints");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/ListDashboardsPaginator.js
var paginateListDashboards = createPaginator(CloudWatchClient, ListDashboardsCommand, "NextToken", "NextToken", "");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/ListManagedInsightRulesPaginator.js
var paginateListManagedInsightRules = createPaginator(CloudWatchClient, ListManagedInsightRulesCommand, "NextToken", "NextToken", "MaxResults");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/ListMetricStreamsPaginator.js
var paginateListMetricStreams = createPaginator(CloudWatchClient, ListMetricStreamsCommand, "NextToken", "NextToken", "MaxResults");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/pagination/ListMetricsPaginator.js
var paginateListMetrics = createPaginator(CloudWatchClient, ListMetricsCommand, "NextToken", "NextToken", "");

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/waiters/waitForAlarmExists.js
var checkState = async (client, input) => {
  let reason;
  try {
    const result = await client.send(new DescribeAlarmsCommand(input));
    reason = result;
    try {
      const returnComparator = () => {
        const flat_1 = [].concat(...result.MetricAlarms);
        return flat_1.length > 0;
      };
      if (returnComparator() == true) {
        return { state: WaiterState.SUCCESS, reason };
      }
    } catch (e2) {
    }
  } catch (exception) {
    reason = exception;
  }
  return { state: WaiterState.RETRY, reason };
};
var waitForAlarmExists = async (params, input) => {
  const serviceDefaults = { minDelay: 5, maxDelay: 120 };
  return createWaiter({ ...serviceDefaults, ...params }, input, checkState);
};
var waitUntilAlarmExists = async (params, input) => {
  const serviceDefaults = { minDelay: 5, maxDelay: 120 };
  const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState);
  return checkExceptions(result);
};

// ../node_modules/@aws-sdk/client-cloudwatch/dist-es/waiters/waitForCompositeAlarmExists.js
var checkState2 = async (client, input) => {
  let reason;
  try {
    const result = await client.send(new DescribeAlarmsCommand(input));
    reason = result;
    try {
      const returnComparator = () => {
        const flat_1 = [].concat(...result.CompositeAlarms);
        return flat_1.length > 0;
      };
      if (returnComparator() == true) {
        return { state: WaiterState.SUCCESS, reason };
      }
    } catch (e2) {
    }
  } catch (exception) {
    reason = exception;
  }
  return { state: WaiterState.RETRY, reason };
};
var waitForCompositeAlarmExists = async (params, input) => {
  const serviceDefaults = { minDelay: 5, maxDelay: 120 };
  return createWaiter({ ...serviceDefaults, ...params }, input, checkState2);
};
var waitUntilCompositeAlarmExists = async (params, input) => {
  const serviceDefaults = { minDelay: 5, maxDelay: 120 };
  const result = await createWaiter({ ...serviceDefaults, ...params }, input, checkState2);
  return checkExceptions(result);
};
export {
  Command as $Command,
  ActionsSuppressedBy,
  AlarmType,
  AnomalyDetectorStateValue,
  AnomalyDetectorType,
  CloudWatch,
  CloudWatchClient,
  CloudWatchServiceException,
  ComparisonOperator,
  ConcurrentModificationException,
  DashboardInvalidInputError,
  DashboardNotFoundError,
  DeleteAlarmsCommand,
  DeleteAnomalyDetectorCommand,
  DeleteDashboardsCommand,
  DeleteInsightRulesCommand,
  DeleteMetricStreamCommand,
  DescribeAlarmHistoryCommand,
  DescribeAlarmsCommand,
  DescribeAlarmsForMetricCommand,
  DescribeAnomalyDetectorsCommand,
  DescribeInsightRulesCommand,
  DisableAlarmActionsCommand,
  DisableInsightRulesCommand,
  EnableAlarmActionsCommand,
  EnableInsightRulesCommand,
  EvaluationState,
  GetDashboardCommand,
  GetInsightRuleReportCommand,
  GetMetricDataCommand,
  GetMetricStatisticsCommand,
  GetMetricStreamCommand,
  GetMetricWidgetImageCommand,
  HistoryItemType,
  InternalServiceFault,
  InvalidFormatFault,
  InvalidNextToken,
  InvalidParameterCombinationException,
  InvalidParameterValueException,
  LimitExceededException,
  LimitExceededFault,
  ListDashboardsCommand,
  ListManagedInsightRulesCommand,
  ListMetricStreamsCommand,
  ListMetricsCommand,
  ListTagsForResourceCommand,
  MetricStreamOutputFormat,
  MissingRequiredParameterException,
  PutAnomalyDetectorCommand,
  PutCompositeAlarmCommand,
  PutDashboardCommand,
  PutInsightRuleCommand,
  PutManagedInsightRulesCommand,
  PutMetricAlarmCommand,
  PutMetricDataCommand,
  PutMetricStreamCommand,
  RecentlyActive,
  ResourceNotFound,
  ResourceNotFoundException,
  ScanBy,
  SetAlarmStateCommand,
  StandardUnit,
  StartMetricStreamsCommand,
  StateValue,
  Statistic,
  StatusCode,
  StopMetricStreamsCommand,
  TagResourceCommand,
  UntagResourceCommand,
  Client as __Client,
  paginateDescribeAlarmHistory,
  paginateDescribeAlarms,
  paginateDescribeAnomalyDetectors,
  paginateDescribeInsightRules,
  paginateGetMetricData,
  paginateListDashboards,
  paginateListManagedInsightRules,
  paginateListMetricStreams,
  paginateListMetrics,
  waitForAlarmExists,
  waitForCompositeAlarmExists,
  waitUntilAlarmExists,
  waitUntilCompositeAlarmExists
};
//# sourceMappingURL=@aws-sdk_client-cloudwatch.js.map
