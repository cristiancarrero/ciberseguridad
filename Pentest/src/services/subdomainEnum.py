from flask import Flask, request, jsonify
from flask_cors import CORS
import dns.resolver
import threading
from queue import Queue
import time
import socket
import requests

app = Flask(__name__)
# Configurar CORS correctamente
CORS(app, resources={
    r"/api/*": {
        "origins": ["http://localhost:5174"],  # Tu origen de desarrollo
        "methods": ["POST", "OPTIONS"],
        "allow_headers": ["Content-Type"]
    }
})

def dns_bruteforce(domain, wordlist):
    """
    Realiza fuerza bruta de DNS para encontrar subdominios
    """
    discovered = []
    resolver = dns.resolver.Resolver()
    resolver.timeout = 0.5  # Reducir timeout a 0.5 segundos
    resolver.lifetime = 0.5
    resolver.nameservers = ['8.8.8.8', '1.1.1.1']  # Usar solo los DNS más rápidos

    def check_subdomain(subdomain, domain, results_queue):
        try:
            hostname = f"{subdomain}.{domain}"
            try:
                answers = resolver.resolve(hostname, 'A')
                ip = str(answers[0])
                print(f"✓ Encontrado: {hostname} -> {ip}")
                results_queue.put({
                    'name': hostname,
                    'ip': ip,
                    'type': 'A'
                })
            except:
                pass  # Ignorar silenciosamente los errores
        except Exception as e:
            print(f"✗ Error en {hostname}")

    results_queue = Queue()
    threads = []
    max_threads = 10  # Limitar número de hilos concurrentes

    # Procesar subdominios en grupos
    for i in range(0, len(wordlist), max_threads):
        batch = wordlist[i:i + max_threads]
        threads = []
        
        for word in batch:
            thread = threading.Thread(
                target=check_subdomain,
                args=(word, domain, results_queue)
            )
            thread.start()
            threads.append(thread)

        # Esperar a que termine este grupo antes de continuar
        for thread in threads:
            thread.join()

    # Recoger resultados
    discovered = []
    while not results_queue.empty():
        discovered.append(results_queue.get())

    return discovered

def scan_ip(ip):
    """
    Realiza un escaneo básico de una IP
    """
    results = []
    
    # 1. Resolución DNS inversa
    try:
        hostname = socket.gethostbyaddr(ip)[0]
        print(f"✓ DNS Reverso encontrado: {hostname}")
        results.append({
            'name': hostname,
            'ip': ip,
            'type': 'PTR',
            'service': 'DNS Reverso'
        })
        
        # Si es una instancia EC2, extraer información
        if 'compute.amazonaws.com' in hostname:
            ec2_info = hostname.split('.')
            region = ec2_info[-3]  # us-west-2
            results.append({
                'name': f'aws-{region}',
                'ip': ip,
                'type': 'INFO',
                'service': f'AWS EC2 Instance ({region})'
            })
    except:
        pass

    # 2. Verificar servicios web comunes
    web_ports = {
        80: 'HTTP',
        443: 'HTTPS',
        8080: 'HTTP-Alt',
        8443: 'HTTPS-Alt',
        22: 'SSH',
        3389: 'RDP'
    }

    for port, service in web_ports.items():
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            if sock.connect_ex((ip, port)) == 0:
                print(f"✓ Puerto {port} ({service}) abierto")
                results.append({
                    'name': f'{service.lower()}.{hostname}' if 'hostname' in locals() else f'port-{port}',
                    'ip': ip,
                    'type': 'PORT',
                    'port': port,
                    'service': service
                })
            sock.close()
        except:
            pass

    return results

def enumerate_subdomains(domain):
    """
    Realiza una enumeración real de subdominios usando múltiples técnicas
    """
    discovered = []
    
    # 1. DNS Bruteforce
    common_subdomains = [
        'www', 'mail', 'remote', 'blog', 'webmail', 'server',
        'ns1', 'ns2', 'smtp', 'secure', 'vpn', 'api', 'dev',
        'staging', 'app', 'admin', 'portal'
    ]

    for sub in common_subdomains:
        try:
            hostname = f"{sub}.{domain}"
            answers = dns.resolver.resolve(hostname, 'A')
            ip = str(answers[0])
            discovered.append({
                'name': hostname,
                'ip': ip,
                'type': 'DNS-A',
                'method': 'bruteforce'
            })
        except:
            continue

    # 2. Búsqueda de registros DNS
    try:
        # MX Records
        mx_records = dns.resolver.resolve(domain, 'MX')
        for mx in mx_records:
            discovered.append({
                'name': str(mx.exchange),
                'ip': '',
                'type': 'DNS-MX',
                'method': 'mx-lookup'
            })
    except:
        pass

    try:
        # NS Records
        ns_records = dns.resolver.resolve(domain, 'NS')
        for ns in ns_records:
            discovered.append({
                'name': str(ns),
                'ip': '',
                'type': 'DNS-NS',
                'method': 'ns-lookup'
            })
    except:
        pass

    return discovered

def check_aws_endpoint(hostname, port=443):
    """
    Verifica si un endpoint AWS es accesible
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex((hostname, port))
        sock.close()
        
        # También intentar una petición HTTPS
        if result == 0:
            try:
                response = requests.get(f"https://{hostname}", timeout=2, verify=False)
                return {
                    'accessible': True,
                    'status_code': response.status_code,
                    'requires_auth': response.status_code in [401, 403]
                }
            except:
                return {'accessible': True, 'requires_auth': True}
        return {'accessible': False}
    except:
        return {'accessible': False}

def enumerate_aws_subdomains(domain):
    """
    Realiza una enumeración específica para dominios AWS
    """
    discovered = []
    resolver = dns.resolver.Resolver()
    resolver.timeout = 1
    resolver.lifetime = 1
    resolver.nameservers = ['8.8.8.8', '1.1.1.1']

    # Extraer región y zona de AWS del dominio
    parts = domain.split('.')
    if 'compute.amazonaws.com' in domain:
        region = parts[-4]  # us-west-2
        zone = parts[-5]    # ec2-35-87-97-69

        # Lista de subdominios AWS comunes
        aws_subdomains = [
            f"internal.{region}",
            f"console.{region}",
            f"api.{region}",
            f"elb.{region}",
            f"s3.{region}",
            f"lambda.{region}",
            f"rds.{region}",
            f"cloudfront.{region}",
            f"dynamodb.{region}",
            f"vpc.{region}",
            f"ecs.{region}",
            f"eks.{region}",
            f"ecr.{region}",
            f"cloudwatch.{region}"
        ]

        # Buscar subdominios AWS
        for sub in aws_subdomains:
            try:
                hostname = f"{sub}.amazonaws.com"
                answers = dns.resolver.resolve(hostname, 'A')
                ip = str(answers[0])
                
                # Verificar accesibilidad
                access_info = check_aws_endpoint(hostname)
                
                discovered.append({
                    'name': hostname,
                    'ip': ip,
                    'type': 'AWS-Service',
                    'region': region,
                    'accessible': access_info['accessible'],
                    'requires_auth': access_info.get('requires_auth', False),
                    'url': f"https://{hostname}"
                })
                
                status = "✓" if access_info['accessible'] else "✗"
                auth = "(requiere auth)" if access_info.get('requires_auth', False) else ""
                print(f"{status} Servicio AWS: {hostname} -> {ip} {auth}")
            except:
                continue

        # Buscar otras instancias EC2 en la misma región
        try:
            pattern = f"*.{region}.compute.amazonaws.com"
            answers = dns.resolver.resolve(pattern, 'A')
            for rdata in answers:
                discovered.append({
                    'name': f"ec2-instance.{region}.compute.amazonaws.com",
                    'ip': str(rdata),
                    'type': 'EC2',
                    'region': region
                })
        except:
            pass

    return discovered

def add_to_hosts(ip, domain, subdomains):
    """
    Añade los subdominios al archivo hosts local
    """
    try:
        with open('/etc/hosts', 'a') as f:
            for sub in subdomains:
                f.write(f"\n{ip}\t{sub}.{domain}")
        return True
    except:
        print("Error: No se pudo modificar el archivo hosts. Ejecuta con sudo.")
        return False

def enumerate_target_subdomains(domain):
    """
    Enumera subdominios específicos del servidor objetivo
    """
    target_subdomains = [
        'www', 'admin', 'api', 'dev', 'test', 'staging',
        'mail', 'db', 'backup', 'internal'
    ]
    
    discovered = []
    try:
        ip = socket.gethostbyname(domain)
        print(f"IP resuelto: {ip}")
        
        for sub in target_subdomains:
            subdomain = f"{sub}.{domain}"
            try:
                # Hacer la petición con el header Host correcto
                response = requests.get(
                    f"http://{ip}",
                    headers={
                        'Host': subdomain,
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    },
                    timeout=5,
                    verify=False,
                    allow_redirects=True
                )
                
                # También intentar conexión directa al subdominio
                try:
                    direct_response = requests.get(
                        f"http://{subdomain}",
                        timeout=5,
                        verify=False,
                        allow_redirects=True
                    )
                    status_code = direct_response.status_code
                except:
                    status_code = response.status_code
                
                if status_code != 404:
                    discovered.append({
                        'name': subdomain,
                        'ip': ip,
                        'type': 'HTTP',
                        'status': status_code,
                        'accessible': status_code not in [404, 502, 503],
                        'requires_auth': status_code in [401, 403],
                        'content': response.text[:100] if status_code == 200 else None
                    })
                    
                    print(f"✓ Encontrado: {subdomain} -> {ip} (Status: {status_code})")
                
            except requests.exceptions.RequestException as e:
                print(f"✗ Error con {subdomain}: {str(e)}")
                continue
                
    except Exception as e:
        print(f"Error resolviendo {domain}: {str(e)}")
        return []
            
    return discovered

@app.route('/api/enumerate', methods=['POST', 'OPTIONS'])
def handle_enumeration():
    if request.method == 'OPTIONS':
        return '', 204

    try:
        data = request.get_json()
        domain = data.get('domain')
        
        if not domain:
            return jsonify({'error': 'Se requiere un dominio'}), 400

        print(f"Iniciando enumeración para: {domain}")

        # Verificar si es nuestra instancia EC2 de prueba
        if domain.startswith('ec2-') and domain.endswith('.compute.amazonaws.com'):
            print("Detectada instancia EC2 de prueba, usando enumeración específica...")
            results = enumerate_target_subdomains(domain)
        # Si es otro dominio de AWS
        elif 'amazonaws.com' in domain:
            results = enumerate_aws_subdomains(domain)
        else:
            # Usar la enumeración normal para otros dominios
            results = enumerate_subdomains(domain)

        return jsonify({
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'domain': domain,
            'results': results,
            'total': len(results)
        })

    except Exception as e:
        print(f"Error: {str(e)}")
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("Iniciando servidor de enumeración en puerto 3003...")
    app.run(port=3003, debug=True) 