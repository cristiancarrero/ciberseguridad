import { EC2Client, DescribeInstancesCommand, StopInstancesCommand, ModifyInstanceAttributeCommand, StartInstancesCommand, AuthorizeSecurityGroupIngressCommand, DescribeSecurityGroupsCommand, RunInstancesCommand, CreateSecurityGroupCommand, waitUntilInstanceRunning, waitUntilInstanceStopped } from "@aws-sdk/client-ec2";
import { CloudWatchClient } from "@aws-sdk/client-cloudwatch";
import { IAMClient, CreateRoleCommand, AttachRolePolicyCommand } from "@aws-sdk/client-iam";
import { S3Client, PutObjectCommand, CreateBucketCommand, PutBucketCorsCommand, PutBucketPolicyCommand, PutBucketWebsiteCommand, PutPublicAccessBlockCommand, PutBucketAclCommand } from "@aws-sdk/client-s3";
import { CloudFrontClient, CreateDistributionCommand } from "@aws-sdk/client-cloudfront";
import { SSMClient, SendCommandCommand } from "@aws-sdk/client-ssm";
import { Route53Client, CreateHostedZoneCommand, ChangeResourceRecordSetsCommand } from "@aws-sdk/client-route-53";

const PENTEST_AWS_CONFIG = 'pentest_aws_config';

let awsClients = {
  ec2: null,
  cloudwatch: null,
  iam: null,
  s3: null
};

export const configureAWS = (credentials) => {
  try {
    const awsConfig = {
      credentials: {
        accessKeyId: credentials.accessKeyId,
        secretAccessKey: credentials.secretAccessKey,
        sessionToken: credentials.sessionToken
      },
      region: credentials.region || 'us-west-2'
    };

    // Guardar en localStorage
    localStorage.setItem(PENTEST_AWS_CONFIG, JSON.stringify(credentials));

    // Inicializar los clientes con las nuevas credenciales
    awsClients.s3 = new S3Client(awsConfig);
    awsClients.ec2 = new EC2Client(awsConfig);
    awsClients.cloudwatch = new CloudWatchClient(awsConfig);
    awsClients.iam = new IAMClient(awsConfig);

    return true;
  } catch (error) {
    console.error('Error configurando AWS:', error);
    return false;
  }
};

export const loadSavedAWSConfig = () => {
  try {
    const savedConfig = localStorage.getItem(PENTEST_AWS_CONFIG);
    if (savedConfig) {
      const config = JSON.parse(savedConfig);
      configureAWS(config);
      return config;
    }
  } catch (error) {
    console.error('Error loading saved AWS config:', error);
  }
  return null;
};

export const isAWSConnected = () => {
  return localStorage.getItem(PENTEST_AWS_CONFIG) !== null;
};

export const getAWSCredentials = () => {
  try {
    const savedConfig = localStorage.getItem(PENTEST_AWS_CONFIG);
    return savedConfig ? JSON.parse(savedConfig) : null;
  } catch (error) {
    console.error('Error getting AWS credentials:', error);
    return null;
  }
};

export const clearAWSConfig = () => {
  try {
    // Limpiar todas las credenciales de localStorage
    localStorage.clear();  // Esto limpiará todo, incluyendo PENTEST_AWS_CONFIG
    
    // Resetear los clientes AWS
    awsClients = {
      ec2: null,
      cloudwatch: null,
      iam: null,
      s3: null
    };

    return true;
  } catch (error) {
    console.error('Error al limpiar configuración AWS:', error);
    return false;
  }
};

// Exportar los clientes AWS
export const getEC2Client = () => awsClients.ec2;
export const getCloudWatchClient = () => awsClients.cloudwatch;
export const getIAMClient = () => awsClients.iam;
export const getS3Client = () => awsClients.s3;

// Función para actualizar las credenciales
export const updateAWSClients = () => {
  const newConfig = getAWSConfig();
  if (!newConfig) {
    return false;
  }
  
  try {
    // Actualizar cada cliente con las nuevas credenciales
    [awsClients.ec2, awsClients.cloudwatch, awsClients.iam, awsClients.s3].forEach(client => {
      if (client) {
        Object.assign(client.config, newConfig);
      }
    });
    return true;
  } catch (error) {
    console.error('Error al actualizar clientes AWS:', error);
    return false;
  }
};

/**
 * Crea un bucket S3 y sube la aplicación
 */
export const deployToS3 = async (bucketName) => {
    try {
        const s3Client = getS3Client();
        if (!s3Client) {
            throw new Error('Cliente S3 no inicializado');
        }

        // 1. Crear bucket con nombre válido para AWS Academy
        console.log('Creando bucket...');
        const uniqueBucketName = `lab-bucket-${Date.now()}`.toLowerCase();
        
        await s3Client.send(new CreateBucketCommand({
            Bucket: uniqueBucketName,
            CreateBucketConfiguration: {
                LocationConstraint: 'us-west-2'
            }
        }));

        // 2. Esperar a que el bucket esté disponible
        await new Promise(resolve => setTimeout(resolve, 2000));

        // 3. Subir archivo HTML simple
        console.log('Subiendo archivo HTML...');
        const testHtml = `
            <!DOCTYPE html>
            <html>
            <head>
                <title>AWS Academy Lab</title>
                <meta charset="utf-8">
            </head>
            <body>
                <h1>Test Page</h1>
                <p>Bucket: ${uniqueBucketName}</p>
                <p>Created: ${new Date().toLocaleString()}</p>
            </body>
            </html>
        `;

        await s3Client.send(new PutObjectCommand({
            Bucket: uniqueBucketName,
            Key: 'index.html',
            Body: testHtml,
            ContentType: 'text/html'
        }));

        // 4. Obtener URL del objeto
        const objectUrl = `https://${uniqueBucketName}.s3.us-west-2.amazonaws.com/index.html`;
        console.log('Despliegue completado');
        console.log('URL:', objectUrl);
        
        return objectUrl;
    } catch (error) {
        console.error('Error en el despliegue:', error);
        if (error.name === 'BucketAlreadyExists') {
            throw new Error('El nombre del bucket ya está en uso. Intenta de nuevo.');
        }
        throw error;
    }
};

/**
 * Configura CloudFront para el bucket S3
 */
export const setupCloudFront = async (bucketName) => {
    try {
        // Obtener credenciales guardadas
        const credentials = getAWSCredentials();
        if (!credentials) {
            throw new Error('No hay credenciales AWS configuradas');
        }

        const cloudFrontClient = new CloudFrontClient({ 
            region: credentials.region,
            credentials: {
                accessKeyId: credentials.accessKeyId,
                secretAccessKey: credentials.secretAccessKey,
                sessionToken: credentials.sessionToken
            }
        });
        
        const distributionConfig = {
            DistributionConfig: {
                CallerReference: Date.now().toString(),
                DefaultRootObject: 'index.html',
                Origins: {
                    Quantity: 1,
                    Items: [
                        {
                            Id: 'S3Origin',
                            DomainName: `${bucketName}.s3-website-us-west-2.amazonaws.com`,
                            CustomOriginConfig: {
                                HTTPPort: 80,
                                HTTPSPort: 443,
                                OriginProtocolPolicy: 'http-only'
                            }
                        }
                    ]
                },
                DefaultCacheBehavior: {
                    TargetOriginId: 'S3Origin',
                    ViewerProtocolPolicy: 'redirect-to-https',
                    AllowedMethods: {
                        Quantity: 2,
                        Items: ['GET', 'HEAD'],
                        CachedMethods: {
                            Quantity: 2,
                            Items: ['GET', 'HEAD']
                        }
                    },
                    ForwardedValues: {
                        QueryString: false,
                        Cookies: {
                            Forward: 'none'
                        }
                    },
                    MinTTL: 0,
                    DefaultTTL: 86400,
                    MaxTTL: 31536000
                },
                Comment: 'Pentest App Distribution',
                Enabled: true
            }
        };

        const response = await cloudFrontClient.send(
            new CreateDistributionCommand(distributionConfig)
        );

        console.log('CloudFront distribution creada:', response.Distribution.DomainName);
        return response.Distribution.DomainName;
    } catch (error) {
        console.error('Error configurando CloudFront:', error);
        throw error;
    }
};

export const deployToEC2 = async () => {
    try {
        const ec2Client = getEC2Client();
        if (!ec2Client) {
            throw new Error('Cliente EC2 no inicializado');
        }

        // 1. Obtener instancias EC2 existentes
        console.log('Buscando instancias EC2...');
        const command = new DescribeInstancesCommand({});
        const response = await ec2Client.send(command);

        // 2. Encontrar una instancia en ejecución
        let targetInstance = null;
        for (const reservation of response.Reservations) {
            for (const instance of reservation.Instances) {
                if (instance.State.Name === 'running') {
                    targetInstance = instance;
                    break;
                }
            }
            if (targetInstance) break;
        }

        if (!targetInstance) {
            throw new Error('No se encontró ninguna instancia EC2 en ejecución');
        }

        // 3. Obtener la IP pública de la instancia
        const publicIp = targetInstance.PublicIpAddress;
        if (!publicIp) {
            throw new Error('La instancia no tiene IP pública');
        }

        // 4. Construir la URL
        const instanceUrl = `http://${publicIp}`;
        console.log('Despliegue completado');
        console.log('URL:', instanceUrl);
        
        return instanceUrl;
    } catch (error) {
        console.error('Error en el despliegue:', error);
        throw error;
    }
};

/**
 * Despliega la aplicación completa
 */
export const deployApplication = async () => {
    try {
        if (!isAWSConnected()) {
            throw new Error('No hay conexión con AWS. Por favor, configura tus credenciales primero.');
        }

        const instanceUrl = await deployToEC2();
        
        return {
            websiteUrl: instanceUrl,
            success: true
        };
    } catch (error) {
        console.error('Error en el despliegue:', error);
        return {
            error: error.message,
            success: false
        };
    }
};

export const deployToCloudFront = async () => {
    try {
        // 1. Crear bucket S3
        const bucketName = `pentest-${Date.now()}`;
        await deployToS3(bucketName);

        // 2. Crear distribución CloudFront
        const cloudFrontClient = new CloudFrontClient({ 
            region: 'us-west-2',
            credentials: getAWSCredentials()
        });

        const distributionConfig = {
            CallerReference: Date.now().toString(),
            Origins: {
                Quantity: 1,
                Items: [{
                    Id: 'S3Origin',
                    DomainName: `${bucketName}.s3.us-west-2.amazonaws.com`,
                    S3OriginConfig: {
                        OriginAccessIdentity: ''
                    }
                }]
            },
            DefaultCacheBehavior: {
                TargetOriginId: 'S3Origin',
                ViewerProtocolPolicy: 'redirect-to-https',
                AllowedMethods: {
                    Quantity: 2,
                    Items: ['GET', 'HEAD']
                },
                ForwardedValues: {
                    QueryString: false,
                    Cookies: { Forward: 'none' }
                }
            },
            Enabled: true,
            Comment: 'Pentest Distribution',
            DefaultRootObject: 'index.html'
        };

        const response = await cloudFrontClient.send(
            new CreateDistributionCommand({ DistributionConfig: distributionConfig })
        );

        const domain = response.Distribution.DomainName;
        console.log('CloudFront Domain:', domain);

        return {
            bucketName,
            cloudFrontDomain: domain,
            success: true
        };
    } catch (error) {
        console.error('Error en CloudFront:', error);
        throw error;
    }
};

export const deployForEnumeration = async () => {
    try {
        const ec2Client = getEC2Client();
        if (!ec2Client) {
            throw new Error('Cliente EC2 no inicializado');
        }

        // 1. Obtener instancias EC2 existentes
        console.log('Buscando instancias EC2...');
        const command = new DescribeInstancesCommand({});
        const response = await ec2Client.send(command);

        // 2. Encontrar una instancia en ejecución
        let targetInstance = null;
        for (const reservation of response.Reservations) {
            for (const instance of reservation.Instances) {
                if (instance.State.Name === 'running') {
                    targetInstance = instance;
                    break;
                }
            }
            if (targetInstance) break;
        }

        if (!targetInstance) {
            throw new Error('No se encontró ninguna instancia EC2 en ejecución');
        }

        // 3. Obtener el DNS público de la instancia
        const publicDns = targetInstance.PublicDnsName;
        if (!publicDns) {
            throw new Error('La instancia no tiene DNS público');
        }

        // 4. Construir la URL y retornar información
        return {
            instanceDns: publicDns,  // Será algo como: ec2-XX-XX-XX-XX.region.compute.amazonaws.com
            instanceIp: targetInstance.PublicIpAddress,
            region: targetInstance.Placement.AvailabilityZone,
            success: true
        };
    } catch (error) {
        console.error('Error en el despliegue:', error);
        return {
            error: error.message,
            success: false
        };
    }
};

const deployTargetScript = `
from flask import Flask, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

# Simular diferentes subdominios
SUBDOMAINS = {
    'www': {'content': 'Sitio web principal'},
    'admin': {'content': 'Panel de administración', 'auth': True},
    'api': {'content': 'API endpoint', 'version': '1.0'},
    'dev': {'content': 'Entorno de desarrollo'},
    'test': {'content': 'Servidor de pruebas'},
    'staging': {'content': 'Entorno de staging'},
    'mail': {'content': 'Servidor de correo'},
    'db': {'content': 'Base de datos', 'auth': True},
    'backup': {'content': 'Servidor de respaldo'},
    'internal': {'content': 'Red interna', 'auth': True}
}

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def catch_all(path):
    subdomain = path.split('.')[0] if '.' in path else 'www'
    
    if subdomain in SUBDOMAINS:
        data = SUBDOMAINS[subdomain]
        if data.get('auth'):
            return jsonify({'error': 'Unauthorized'}), 401
        return jsonify(data)
    
    return jsonify({'error': 'Not Found'}), 404

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
`;

const checkAndConfigureSSM = async (instanceId) => {
    try {
        const credentials = getAWSCredentials();
        if (!credentials) {
            throw new Error('No hay credenciales AWS configuradas');
        }

        const ssmClient = new SSMClient({ 
            region: 'us-west-2',
            credentials: {
                accessKeyId: credentials.accessKeyId,
                secretAccessKey: credentials.secretAccessKey,
                sessionToken: credentials.sessionToken
            }
        });
        
        // Verificar si la instancia está lista para SSM
        const checkCommand = new SendCommandCommand({
            InstanceIds: [instanceId],
            DocumentName: 'AWS-RunShellScript',
            Parameters: {
                commands: ['echo "Testing SSM access"']
            }
        });

        await ssmClient.send(checkCommand);
        return true;
    } catch (error) {
        console.error('Error con SSM:', error);
        if (error.message.includes('not registered')) {
            throw new Error('La instancia no está configurada para SSM. Por favor, asegúrate de que tiene el rol AWSSystemsManagerRole.');
        }
        throw error;
    }
};

export const deployTargetServer = async () => {
    try {
        const ec2Client = getEC2Client();
        if (!ec2Client) {
            throw new Error('Cliente EC2 no inicializado');
        }

        // 1. Obtener instancia EC2
        const command = new DescribeInstancesCommand({});
        const response = await ec2Client.send(command);
        
        let instance = null;
        for (const reservation of response.Reservations) {
            for (const inst of reservation.Instances) {
                if (inst.State.Name === 'running') {
                    instance = inst;
                    break;
                }
            }
            if (instance) break;
        }

        if (!instance) {
            throw new Error('No se encontró ninguna instancia EC2 en ejecución');
        }

        // 2. Verificar y configurar grupo de seguridad para el puerto 80
        const securityGroupId = instance.SecurityGroups[0].GroupId;
        
        // Verificar reglas existentes
        const sgResponse = await ec2Client.send(new DescribeSecurityGroupsCommand({
            GroupIds: [securityGroupId]
        }));

        const hasPort80Rule = sgResponse.SecurityGroups[0].IpPermissions.some(
            permission => 
                permission.IpProtocol === 'tcp' && 
                permission.FromPort === 80 && 
                permission.ToPort === 80 &&
                permission.IpRanges.some(range => range.CidrIp === '0.0.0.0/0')
        );

        // Solo añadir la regla si no existe
        if (!hasPort80Rule) {
            await ec2Client.send(new AuthorizeSecurityGroupIngressCommand({
                GroupId: securityGroupId,
                IpPermissions: [{
                    IpProtocol: 'tcp',
                    FromPort: 80,
                    ToPort: 80,
                    IpRanges: [{ CidrIp: '0.0.0.0/0' }]
                }]
            }));
            console.log('Puerto 80 abierto en el grupo de seguridad');
        } else {
            console.log('El puerto 80 ya está abierto');
        }

        // 3. Retornar información de la instancia
        // En este punto, el puerto 80 está abierto y podemos acceder a la instancia
        return {
            instanceDns: instance.PublicDnsName,
            instanceIp: instance.PublicIpAddress,
            region: instance.Placement.AvailabilityZone,
            success: true
        };
    } catch (error) {
        console.error('Error configurando servidor:', error);
        return {
            error: error.message,
            success: false
        };
    }
};

export const createTestInstance = async () => {
    try {
        const ec2Client = getEC2Client();
        if (!ec2Client) {
            throw new Error('Cliente EC2 no inicializado');
        }

        // 1. Obtener instancia existente
        const command = new DescribeInstancesCommand({});
        const response = await ec2Client.send(command);
        
        let instance = null;
        for (const reservation of response.Reservations) {
            for (const inst of reservation.Instances) {
                if (inst.State.Name === 'running') {
                    instance = inst;
                    break;
                }
            }
            if (instance) break;
        }

        if (!instance) {
            throw new Error('No se encontró ninguna instancia EC2 en ejecución');
        }

        // 2. Configurar grupo de seguridad
        const securityGroupId = instance.SecurityGroups[0].GroupId;
        
        // Verificar reglas existentes
        const sgResponse = await ec2Client.send(new DescribeSecurityGroupsCommand({
            GroupIds: [securityGroupId]
        }));

        const hasPort80Rule = sgResponse.SecurityGroups[0].IpPermissions.some(
            permission => 
                permission.IpProtocol === 'tcp' && 
                permission.FromPort === 80 && 
                permission.ToPort === 80 &&
                permission.IpRanges.some(range => range.CidrIp === '0.0.0.0/0')
        );

        // Solo añadir la regla si no existe
        if (!hasPort80Rule) {
            await ec2Client.send(new AuthorizeSecurityGroupIngressCommand({
                GroupId: securityGroupId,
                IpPermissions: [{
                    IpProtocol: 'tcp',
                    FromPort: 80,
                    ToPort: 80,
                    IpRanges: [{ CidrIp: '0.0.0.0/0' }]
                }]
            }));
            console.log('Puerto 80 abierto en el grupo de seguridad');
        } else {
            console.log('El puerto 80 ya está abierto');
        }

        // 3. Detener la instancia
        console.log('Deteniendo instancia...');
        await ec2Client.send(new StopInstancesCommand({
            InstanceIds: [instance.InstanceId]
        }));

        // 4. Esperar a que la instancia esté detenida
        console.log('Esperando a que la instancia se detenga...');
        await waitUntilInstanceStopped(
            { client: ec2Client },
            { InstanceIds: [instance.InstanceId] }
        );

        // 5. Configurar el script de inicio
        const scriptContent = `#!/bin/bash
# Actualizar e instalar paquetes
yum update -y
yum install -y httpd mod_ssl python3-pip
pip3 install flask flask-cors

# Habilitar y arrancar Apache
systemctl enable httpd
systemctl start httpd

# Configurar virtual hosts para subdominios
cat > /etc/httpd/conf.d/vhosts.conf << 'EOL'
<VirtualHost *:80>
    ServerName ${instance.PublicDnsName}
    DocumentRoot /var/www/html
    
    # Configuración para subdominios virtuales
    <If "%{HTTP_HOST} =~ /^www\./i">
        DocumentRoot /var/www/html/www
    </If>
    
    <If "%{HTTP_HOST} =~ /^admin\./i">
        DocumentRoot /var/www/html/admin
        <Directory /var/www/html/admin>
            AuthType Basic
            AuthName "Admin Area"
            AuthUserFile /etc/httpd/.htpasswd
            Require valid-user
        </Directory>
    </If>
    
    <If "%{HTTP_HOST} =~ /^api\./i">
        DocumentRoot /var/www/html/api
    </If>
    
    <If "%{HTTP_HOST} =~ /^(dev|test|staging|mail|db|backup|internal)\./i">
        DocumentRoot "/var/www/html/%1"
    </If>
</VirtualHost>
EOL

# Crear directorios y contenido de ejemplo
for subdir in www admin api dev test staging mail db backup internal; do
    mkdir -p /var/www/html/$subdir
    echo "<h1>Welcome to $subdir subdomain</h1><p>This is a test page for ${instance.PublicDnsName}</p>" > /var/www/html/$subdir/index.html
    chown -R apache:apache /var/www/html/$subdir
done

# Crear usuario y contraseña para subdominios protegidos
htpasswd -cb /etc/httpd/.htpasswd admin password123

# Asegurar permisos
chmod 644 /etc/httpd/conf.d/vhosts.conf
chmod 644 /etc/httpd/.htpasswd
chown root:apache /etc/httpd/.htpasswd

# Reiniciar Apache para aplicar cambios
systemctl restart httpd

# Esperar a que Apache esté listo
sleep 10

# Verificar que Apache está funcionando
curl -s http://localhost > /dev/null
if [ $? -eq 0 ]; then
    echo "Apache está funcionando correctamente"
else
    echo "Error: Apache no está respondiendo"
fi`;

        // 6. Actualizar el UserData de la instancia
        await ec2Client.send(new ModifyInstanceAttributeCommand({
            InstanceId: instance.InstanceId,
            UserData: { Value: btoa(scriptContent) }
        }));

        // 7. Iniciar la instancia
        console.log('Iniciando instancia...');
        await ec2Client.send(new StartInstancesCommand({
            InstanceIds: [instance.InstanceId]
        }));

        // 8. Esperar a que la instancia esté en ejecución
        console.log('Esperando a que la instancia esté lista...');
        await waitUntilInstanceRunning(
            { client: ec2Client },
            { InstanceIds: [instance.InstanceId] }
        );

        // 9. Obtener información actualizada
        const describeResponse = await ec2Client.send(new DescribeInstancesCommand({
            InstanceIds: [instance.InstanceId]
        }));

        const updatedInstance = describeResponse.Reservations[0].Instances[0];

        console.log('Esperando a que los servicios estén listos...');
        await new Promise(resolve => setTimeout(resolve, 60000));

        return {
            instanceId: updatedInstance.InstanceId,
            publicDns: updatedInstance.PublicDnsName,
            publicIp: updatedInstance.PublicIpAddress,
            success: true
        };

    } catch (error) {
        console.error('Error configurando instancia de prueba:', error);
        return {
            error: error.message,
            success: false
        };
    }
};

const getRunningInstance = async () => {
    const ec2Client = getEC2Client();
    const response = await ec2Client.send(new DescribeInstancesCommand({}));
    
    let instance = null;
    for (const reservation of response.Reservations) {
        for (const inst of reservation.Instances) {
            if (inst.State.Name === 'running') {
                instance = inst;
                break;
            }
        }
        if (instance) break;
    }

    if (!instance) {
        throw new Error('No se encontró ninguna instancia EC2 en ejecución');
    }

    return instance;
};

const configureInstance = async (instanceId, userDataScript) => {
    const ec2Client = getEC2Client();

    // 1. Detener la instancia
    console.log('Deteniendo instancia...');
    await ec2Client.send(new StopInstancesCommand({
        InstanceIds: [instanceId]
    }));

    // 2. Esperar a que se detenga
    console.log('Esperando a que la instancia se detenga...');
    await waitUntilInstanceStopped(
        { client: ec2Client },
        { InstanceIds: [instanceId] }
    );

    // 3. Actualizar UserData
    console.log('Actualizando configuración...');
    await ec2Client.send(new ModifyInstanceAttributeCommand({
        InstanceId: instanceId,
        UserData: { Value: btoa(userDataScript) }
    }));

    // 4. Iniciar la instancia
    console.log('Iniciando instancia...');
    await ec2Client.send(new StartInstancesCommand({
        InstanceIds: [instanceId]
    }));

    // 5. Esperar a que esté en ejecución
    console.log('Esperando a que la instancia esté lista...');
    await waitUntilInstanceRunning(
        { client: ec2Client },
        { InstanceIds: [instanceId] }
    );

    // 6. Esperar a que Apache se configure (aumentar a 2 minutos)
    console.log('Esperando a que los servicios se configuren...');
    await new Promise(resolve => setTimeout(resolve, 120000));
};

export const createTestSubdomains = async () => {
    try {
        // 1. Obtener la instancia EC2
        const instance = await getRunningInstance();

        // 2. Configurar Apache con virtual hosts
        const userDataScript = `#!/bin/bash
yum update -y
yum install -y httpd mod_ssl

# Habilitar mod_rewrite (en Amazon Linux)
sed -i 's/#LoadModule rewrite_module/LoadModule rewrite_module/' /etc/httpd/conf.modules.d/00-base.conf

# Configurar virtual hosts con ServerAlias
cat > /etc/httpd/conf.d/vhosts.conf << 'EOL'
<VirtualHost *:80>
    ServerName ${instance.PublicDnsName}
    ServerAlias *.${instance.PublicDnsName}
    DocumentRoot /var/www/html

    <Directory /var/www/html>
        Options Indexes FollowSymLinks MultiViews
        AllowOverride All
        Require all granted
    </Directory>

    <Directory /var/www/html/subdomains>
        Options Indexes FollowSymLinks MultiViews
        AllowOverride All
        Require all granted
        
        RewriteEngine On
        RewriteBase /
    </Directory>
</VirtualHost>

# Configuración de subdominios específicos
<VirtualHost *:80>
    ServerAlias www.${instance.PublicDnsName}
    DocumentRoot /var/www/html/subdomains/www
</VirtualHost>

<VirtualHost *:80>
    ServerAlias admin.${instance.PublicDnsName}
    DocumentRoot /var/www/html/subdomains/admin
    <Directory /var/www/html/subdomains/admin>
        AuthType Basic
        AuthName "Admin Area"
        AuthUserFile /etc/httpd/.htpasswd
        Require valid-user
    </Directory>
</VirtualHost>

<VirtualHost *:80>
    ServerAlias api.${instance.PublicDnsName}
    DocumentRoot /var/www/html/subdomains/api
</VirtualHost>

<VirtualHost *:80>
    ServerAlias dev.${instance.PublicDnsName}
    DocumentRoot /var/www/html/subdomains/dev
</VirtualHost>

<VirtualHost *:80>
    ServerAlias test.${instance.PublicDnsName}
    DocumentRoot /var/www/html/subdomains/test
</VirtualHost>
EOL

# Crear estructura y contenido
mkdir -p /var/www/html/subdomains/{www,admin,api,dev,test}
chown -R apache:apache /var/www/html

# Contenido de prueba
cat > /var/www/html/subdomains/www/index.html << EOF
<!DOCTYPE html>
<html><head><title>Welcome</title></head>
<body>
    <h1>Welcome to ${instance.PublicDnsName}</h1>
    <p>Main website</p>
</body></html>
EOF

cat > /var/www/html/subdomains/admin/index.html << EOF
<!DOCTYPE html>
<html><head><title>Admin Panel</title></head>
<body>
    <h1>Admin Panel</h1>
    <p>Restricted area - Authentication required</p>
</body></html>
EOF

cat > /var/www/html/subdomains/api/index.html << EOF
{"status":"running","version":"1.0","server":"${instance.PublicDnsName}","timestamp":"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"}
EOF

cat > /var/www/html/subdomains/dev/index.html << EOF
<!DOCTYPE html>
<html><head><title>Development Environment</title></head>
<body>
    <h1>Development Environment</h1>
    <pre>
    Environment: Development
    Server: ${instance.PublicDnsName}
    Version: dev-1.0.0
    Last Deploy: $(date)
    </pre>
</body></html>
EOF

cat > /var/www/html/subdomains/test/index.html << EOF
<!DOCTYPE html>
<html><head><title>Test Environment</title></head>
<body>
    <h1>Test Environment</h1>
    <div class="test-results">
        <h2>Latest Test Results</h2>
        <pre>
Tests Run: 128
Passed: 124
Failed: 4
Coverage: 87%
Last Run: $(date)
        </pre>
    </div>
</body></html>
EOF

# Proteger admin
htpasswd -cb /etc/httpd/.htpasswd admin password123

# Asegurar permisos
chmod -R 755 /var/www/html
chmod 644 /etc/httpd/conf.d/vhosts.conf
chmod 644 /etc/httpd/.htpasswd
chown root:apache /etc/httpd/.htpasswd

# Reiniciar y verificar
systemctl enable httpd
systemctl restart httpd

# Test de acceso
for sub in www admin api dev test; do
    echo "Probando $sub.${instance.PublicDnsName}..."
    curl -H "Host: $sub.${instance.PublicDnsName}" http://localhost/
done`;

        // 3. Aplicar configuración
        await configureInstance(instance.InstanceId, userDataScript);

        // 4. Retornar información
        const subdomains = ['www', 'admin', 'api', 'dev', 'test'];
        return {
            domain: instance.PublicDnsName,
            subdomains: subdomains.map(sub => ({
                name: `${sub}.${instance.PublicDnsName}`,
                url: `http://${sub}.${instance.PublicDnsName}`,
                type: sub === 'admin' ? 'protected' : 'public'
            }))
        };

    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
};

export const createSQLTestEnvironment = async () => {
    try {
        // Verificar credenciales
        const credentials = getAWSCredentials();
        if (!credentials) {
            throw new Error('No hay credenciales AWS configuradas');
        }

        // Crear cliente EC2 con las credenciales
        const ec2Client = new EC2Client({
            region: credentials.region || 'us-west-2',
            credentials: {
                accessKeyId: credentials.accessKeyId,
                secretAccessKey: credentials.secretAccessKey,
                sessionToken: credentials.sessionToken
            }
        });
        
        // Script de inicio para configurar el servidor
        const userData = btoa(`#!/bin/bash
# Habilitar logs detallados
set -x
exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1

# Actualizar e instalar paquetes
yum update -y
yum install -y httpd php php-mysql

# Configurar Apache para permitir conexiones
sed -i 's/Listen 80/Listen 0.0.0.0:80/' /etc/httpd/conf/httpd.conf

# Asegurarse de que el directorio existe y tiene permisos correctos
mkdir -p /var/www/html
chown -R apache:apache /var/www/html

# Crear archivo PHP vulnerable
cat > /var/www/html/test.php << 'EOF'
<?php
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');

$user = $_GET['user'] ?? '';
$pass = $_GET['pass'] ?? '';

// Simulación de consulta SQL vulnerable
$query = "SELECT * FROM users WHERE username='$user' AND password='$pass'";

echo json_encode([
    'message' => "Ejecutando query: $query",
    'status' => 'error',
    'details' => 'Invalid credentials'
]);
?>
EOF

# Configurar permisos
chown apache:apache /var/www/html/test.php
chmod 644 /var/www/html/test.php

# Deshabilitar SELinux
setenforce 0
sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config

# Configurar firewall
systemctl stop firewalld
systemctl disable firewalld

# Iniciar y habilitar Apache
systemctl enable httpd
systemctl start httpd

# Esperar 30 segundos para asegurarnos de que Apache está completamente iniciado
sleep 30

# Verificar que Apache está corriendo y reiniciar si es necesario
if ! systemctl is-active --quiet httpd; then
    echo "Apache no está corriendo, intentando reiniciar..."
    systemctl restart httpd
    sleep 10
fi

# Verificar que el puerto 80 está escuchando
if ! netstat -tulpn | grep :80; then
    echo "Puerto 80 no está escuchando, verificando configuración..."
    cat /etc/httpd/conf/httpd.conf
    systemctl restart httpd
    sleep 10
fi

# Verificar permisos y contenido
ls -la /var/www/html/
cat /var/www/html/test.php

# Intentar acceder localmente
curl -v http://localhost/test.php

# Mostrar logs para diagnóstico
echo "=== Error Log ==="
tail -n 50 /var/log/httpd/error_log
echo "=== Access Log ==="
tail -n 50 /var/log/httpd/access_log`);

        // Crear grupo de seguridad
        const sgResponse = await ec2Client.send(new CreateSecurityGroupCommand({
            GroupName: `sql-test-sg-${Date.now()}`,
            Description: 'Security group for SQL injection testing'
        }));

        // Crear instancia EC2
        const response = await ec2Client.send(new RunInstancesCommand({
            ImageId: 'ami-0735c191cf914754d', // Amazon Linux 2
            InstanceType: 't2.micro',
            MinCount: 1,
            MaxCount: 1,
            UserData: userData,
            SecurityGroupIds: [sgResponse.GroupId],
            TagSpecifications: [
                {
                    ResourceType: 'instance',
                    Tags: [
                        {
                            Key: 'Name',
                            Value: 'SQL-Injection-Test'
                        }
                    ]
                }
            ]
        }));

        const instanceId = response.Instances[0].InstanceId;

        // Esperar a que la instancia esté corriendo
        await waitUntilInstanceRunning(
            { client: ec2Client, maxWaitTime: 120 },
            { InstanceIds: [instanceId] }
        );

        // Obtener información de la instancia
        const describeResponse = await ec2Client.send(new DescribeInstancesCommand({
            InstanceIds: [instanceId]
        }));

        const instance = describeResponse.Reservations[0].Instances[0];
        const publicIp = instance.PublicIpAddress;

        // Añadir reglas de seguridad para el puerto 80
        await ec2Client.send(new AuthorizeSecurityGroupIngressCommand({
            GroupId: sgResponse.GroupId,
            IpPermissions: [
                {
                    IpProtocol: 'tcp',
                    FromPort: 80,
                    ToPort: 80,
                    IpRanges: [{ CidrIp: '0.0.0.0/0' }]
                }
            ]
        }));

        return {
            instanceId,
            url: `http://${publicIp}/test.php`,
            ip: publicIp
        };

    } catch (error) {
        console.error('Error creating test environment:', error);
        throw error;
    }
};
